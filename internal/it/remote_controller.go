/*
 * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License")
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Code generated by Thrift Compiler (0.14.1). DO NOT EDIT.

package it

import (
	"bytes"
	"context"
	"database/sql/driver"
	"errors"
	"fmt"
	"time"

	"github.com/apache/thrift/lib/go/thrift"
)

// (needed to ensure safety because of naive import list construction.)
var _ = thrift.ZERO
var _ = fmt.Printf
var _ = context.Background
var _ = time.Now
var _ = bytes.Equal

type Lang int64

const (
	Lang_JAVASCRIPT Lang = 1
	Lang_GROOVY     Lang = 2
	Lang_PYTHON     Lang = 3
	Lang_RUBY       Lang = 4
)

func (p Lang) String() string {
	switch p {
	case Lang_JAVASCRIPT:
		return "JAVASCRIPT"
	case Lang_GROOVY:
		return "GROOVY"
	case Lang_PYTHON:
		return "PYTHON"
	case Lang_RUBY:
		return "RUBY"
	}
	return "<UNSET>"
}

func LangFromString(s string) (Lang, error) {
	switch s {
	case "JAVASCRIPT":
		return Lang_JAVASCRIPT, nil
	case "GROOVY":
		return Lang_GROOVY, nil
	case "PYTHON":
		return Lang_PYTHON, nil
	case "RUBY":
		return Lang_RUBY, nil
	}
	return Lang(0), fmt.Errorf("not a valid Lang string")
}

func LangPtr(v Lang) *Lang { return &v }

func (p Lang) MarshalText() ([]byte, error) {
	return []byte(p.String()), nil
}

func (p *Lang) UnmarshalText(text []byte) error {
	q, err := LangFromString(string(text))
	if err != nil {
		return err
	}
	*p = q
	return nil
}

func (p *Lang) Scan(value interface{}) error {
	v, ok := value.(int64)
	if !ok {
		return errors.New("Scan value is not int64")
	}
	*p = Lang(v)
	return nil
}

func (p *Lang) Value() (driver.Value, error) {
	if p == nil {
		return nil, nil
	}
	return int64(*p), nil
}

// Attributes:
//  - ID
type Cluster struct {
	ID string `thrift:"id,1" db:"id" json:"id"`
}

func NewCluster() *Cluster {
	return &Cluster{}
}

func (p *Cluster) GetID() string {
	return p.ID
}
func (p *Cluster) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *Cluster) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.ID = v
	}
	return nil
}

func (p *Cluster) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "Cluster"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *Cluster) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "id", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:id: ", p), err)
	}
	if err := oprot.WriteString(ctx, string(p.ID)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.id (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:id: ", p), err)
	}
	return err
}

func (p *Cluster) Equals(other *Cluster) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if p.ID != other.ID {
		return false
	}
	return true
}

func (p *Cluster) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("Cluster(%+v)", *p)
}

// Attributes:
//  - UUID
//  - Host
//  - Port
type Member struct {
	UUID string `thrift:"uuid,1" db:"uuid" json:"uuid"`
	Host string `thrift:"host,2" db:"host" json:"host"`
	Port int32  `thrift:"port,3" db:"port" json:"port"`
}

func NewMember() *Member {
	return &Member{}
}

func (p *Member) GetUUID() string {
	return p.UUID
}

func (p *Member) GetHost() string {
	return p.Host
}

func (p *Member) GetPort() int32 {
	return p.Port
}
func (p *Member) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 3:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField3(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *Member) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.UUID = v
	}
	return nil
}

func (p *Member) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.Host = v
	}
	return nil
}

func (p *Member) ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		p.Port = v
	}
	return nil
}

func (p *Member) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "Member"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField3(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *Member) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "uuid", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:uuid: ", p), err)
	}
	if err := oprot.WriteString(ctx, string(p.UUID)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.uuid (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:uuid: ", p), err)
	}
	return err
}

func (p *Member) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "host", thrift.STRING, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:host: ", p), err)
	}
	if err := oprot.WriteString(ctx, string(p.Host)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.host (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:host: ", p), err)
	}
	return err
}

func (p *Member) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "port", thrift.I32, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:port: ", p), err)
	}
	if err := oprot.WriteI32(ctx, int32(p.Port)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.port (3) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:port: ", p), err)
	}
	return err
}

func (p *Member) Equals(other *Member) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if p.UUID != other.UUID {
		return false
	}
	if p.Host != other.Host {
		return false
	}
	if p.Port != other.Port {
		return false
	}
	return true
}

func (p *Member) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("Member(%+v)", *p)
}

// Attributes:
//  - Success
//  - Message
//  - Result_
type Response struct {
	Message string `thrift:"message,2" db:"message" json:"message"`
	Result_ []byte `thrift:"result,3" db:"result" json:"result"`
	Success bool   `thrift:"success,1" db:"success" json:"success"`
}

func NewResponse() *Response {
	return &Response{}
}

func (p *Response) GetSuccess() bool {
	return p.Success
}

func (p *Response) GetMessage() string {
	return p.Message
}

func (p *Response) GetResult_() []byte {
	return p.Result_
}
func (p *Response) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.BOOL {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 3:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField3(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *Response) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Success = v
	}
	return nil
}

func (p *Response) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.Message = v
	}
	return nil
}

func (p *Response) ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		p.Result_ = v
	}
	return nil
}

func (p *Response) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "Response"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField3(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *Response) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "success", thrift.BOOL, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:success: ", p), err)
	}
	if err := oprot.WriteBool(ctx, bool(p.Success)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.success (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:success: ", p), err)
	}
	return err
}

func (p *Response) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "message", thrift.STRING, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:message: ", p), err)
	}
	if err := oprot.WriteString(ctx, string(p.Message)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.message (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:message: ", p), err)
	}
	return err
}

func (p *Response) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "result", thrift.STRING, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:result: ", p), err)
	}
	if err := oprot.WriteBinary(ctx, p.Result_); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.result (3) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:result: ", p), err)
	}
	return err
}

func (p *Response) Equals(other *Response) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if p.Success != other.Success {
		return false
	}
	if p.Message != other.Message {
		return false
	}
	if bytes.Compare(p.Result_, other.Result_) != 0 {
		return false
	}
	return true
}

func (p *Response) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("Response(%+v)", *p)
}

// Attributes:
//  - Message
type ServerException struct {
	Message string `thrift:"message,1" db:"message" json:"message"`
}

func NewServerException() *ServerException {
	return &ServerException{}
}

func (p *ServerException) GetMessage() string {
	return p.Message
}
func (p *ServerException) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ServerException) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Message = v
	}
	return nil
}

func (p *ServerException) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "ServerException"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ServerException) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "message", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:message: ", p), err)
	}
	if err := oprot.WriteString(ctx, string(p.Message)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.message (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:message: ", p), err)
	}
	return err
}

func (p *ServerException) Equals(other *ServerException) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if p.Message != other.Message {
		return false
	}
	return true
}

func (p *ServerException) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ServerException(%+v)", *p)
}

func (p *ServerException) Error() string {
	return p.String()
}

func (ServerException) TExceptionType() thrift.TExceptionType {
	return thrift.TExceptionTypeCompiled
}

var _ thrift.TException = (*ServerException)(nil)

type RemoteController interface {
	Ping(ctx context.Context) (_r bool, _err error)
	Clean(ctx context.Context) (_r bool, _err error)
	Exit(ctx context.Context) (_r bool, _err error)
	// Parameters:
	//  - HzVersion
	//  - Xmlconfig
	CreateCluster(ctx context.Context, hzVersion string, xmlconfig string) (_r *Cluster, _err error)
	// Parameters:
	//  - HzVersion
	//  - Xmlconfig
	CreateClusterKeepClusterName(ctx context.Context, hzVersion string, xmlconfig string) (_r *Cluster, _err error)
	// Parameters:
	//  - ClusterId
	StartMember(ctx context.Context, clusterId string) (_r *Member, _err error)
	// Parameters:
	//  - ClusterId
	//  - MemberId
	ShutdownMember(ctx context.Context, clusterId string, memberId string) (_r bool, _err error)
	// Parameters:
	//  - ClusterId
	//  - MemberId
	TerminateMember(ctx context.Context, clusterId string, memberId string) (_r bool, _err error)
	// Parameters:
	//  - ClusterId
	//  - MemberId
	SuspendMember(ctx context.Context, clusterId string, memberId string) (_r bool, _err error)
	// Parameters:
	//  - ClusterId
	//  - MemberId
	ResumeMember(ctx context.Context, clusterId string, memberId string) (_r bool, _err error)
	// Parameters:
	//  - ClusterId
	ShutdownCluster(ctx context.Context, clusterId string) (_r bool, _err error)
	// Parameters:
	//  - ClusterId
	TerminateCluster(ctx context.Context, clusterId string) (_r bool, _err error)
	// Parameters:
	//  - MemberId
	SplitMemberFromCluster(ctx context.Context, memberId string) (_r *Cluster, _err error)
	// Parameters:
	//  - ClusterId
	//  - MemberId
	MergeMemberToCluster(ctx context.Context, clusterId string, memberId string) (_r *Cluster, _err error)
	// Parameters:
	//  - ClusterId
	//  - Script
	//  - Lang
	ExecuteOnController(ctx context.Context, clusterId string, script string, lang Lang) (_r *Response, _err error)
}

type RemoteControllerClient struct {
	c    thrift.TClient
	meta thrift.ResponseMeta
}

func NewRemoteControllerClientFactory(t thrift.TTransport, f thrift.TProtocolFactory) *RemoteControllerClient {
	return &RemoteControllerClient{
		c: thrift.NewTStandardClient(f.GetProtocol(t), f.GetProtocol(t)),
	}
}

func NewRemoteControllerClientProtocol(t thrift.TTransport, iprot thrift.TProtocol, oprot thrift.TProtocol) *RemoteControllerClient {
	return &RemoteControllerClient{
		c: thrift.NewTStandardClient(iprot, oprot),
	}
}

func NewRemoteControllerClient(c thrift.TClient) *RemoteControllerClient {
	return &RemoteControllerClient{
		c: c,
	}
}

func (p *RemoteControllerClient) Client_() thrift.TClient {
	return p.c
}

func (p *RemoteControllerClient) LastResponseMeta_() thrift.ResponseMeta {
	return p.meta
}

func (p *RemoteControllerClient) SetLastResponseMeta_(meta thrift.ResponseMeta) {
	p.meta = meta
}

func (p *RemoteControllerClient) Ping(ctx context.Context) (_r bool, _err error) {
	var _args0 RemoteControllerPingArgs
	var _result2 RemoteControllerPingResult
	var _meta1 thrift.ResponseMeta
	_meta1, _err = p.Client_().Call(ctx, "ping", &_args0, &_result2)
	p.SetLastResponseMeta_(_meta1)
	if _err != nil {
		return
	}
	return _result2.GetSuccess(), nil
}

func (p *RemoteControllerClient) Clean(ctx context.Context) (_r bool, _err error) {
	var _args3 RemoteControllerCleanArgs
	var _result5 RemoteControllerCleanResult
	var _meta4 thrift.ResponseMeta
	_meta4, _err = p.Client_().Call(ctx, "clean", &_args3, &_result5)
	p.SetLastResponseMeta_(_meta4)
	if _err != nil {
		return
	}
	return _result5.GetSuccess(), nil
}

func (p *RemoteControllerClient) Exit(ctx context.Context) (_r bool, _err error) {
	var _args6 RemoteControllerExitArgs
	var _result8 RemoteControllerExitResult
	var _meta7 thrift.ResponseMeta
	_meta7, _err = p.Client_().Call(ctx, "exit", &_args6, &_result8)
	p.SetLastResponseMeta_(_meta7)
	if _err != nil {
		return
	}
	return _result8.GetSuccess(), nil
}

// Parameters:
//  - HzVersion
//  - Xmlconfig
func (p *RemoteControllerClient) CreateCluster(ctx context.Context, hzVersion string, xmlconfig string) (_r *Cluster, _err error) {
	var _args9 RemoteControllerCreateClusterArgs
	_args9.HzVersion = hzVersion
	_args9.Xmlconfig = xmlconfig
	var _result11 RemoteControllerCreateClusterResult
	var _meta10 thrift.ResponseMeta
	_meta10, _err = p.Client_().Call(ctx, "createCluster", &_args9, &_result11)
	p.SetLastResponseMeta_(_meta10)
	if _err != nil {
		return
	}
	switch {
	case _result11.ServerException != nil:
		return _r, _result11.ServerException
	}

	return _result11.GetSuccess(), nil
}

// Parameters:
//  - HzVersion
//  - Xmlconfig
func (p *RemoteControllerClient) CreateClusterKeepClusterName(ctx context.Context, hzVersion string, xmlconfig string) (_r *Cluster, _err error) {
	var _args12 RemoteControllerCreateClusterKeepClusterNameArgs
	_args12.HzVersion = hzVersion
	_args12.Xmlconfig = xmlconfig
	var _result14 RemoteControllerCreateClusterKeepClusterNameResult
	var _meta13 thrift.ResponseMeta
	_meta13, _err = p.Client_().Call(ctx, "createClusterKeepClusterName", &_args12, &_result14)
	p.SetLastResponseMeta_(_meta13)
	if _err != nil {
		return
	}
	switch {
	case _result14.ServerException != nil:
		return _r, _result14.ServerException
	}

	return _result14.GetSuccess(), nil
}

// Parameters:
//  - ClusterId
func (p *RemoteControllerClient) StartMember(ctx context.Context, clusterId string) (_r *Member, _err error) {
	var _args15 RemoteControllerStartMemberArgs
	_args15.ClusterId = clusterId
	var _result17 RemoteControllerStartMemberResult
	var _meta16 thrift.ResponseMeta
	_meta16, _err = p.Client_().Call(ctx, "startMember", &_args15, &_result17)
	p.SetLastResponseMeta_(_meta16)
	if _err != nil {
		return
	}
	switch {
	case _result17.ServerException != nil:
		return _r, _result17.ServerException
	}

	return _result17.GetSuccess(), nil
}

// Parameters:
//  - ClusterId
//  - MemberId
func (p *RemoteControllerClient) ShutdownMember(ctx context.Context, clusterId string, memberId string) (_r bool, _err error) {
	var _args18 RemoteControllerShutdownMemberArgs
	_args18.ClusterId = clusterId
	_args18.MemberId = memberId
	var _result20 RemoteControllerShutdownMemberResult
	var _meta19 thrift.ResponseMeta
	_meta19, _err = p.Client_().Call(ctx, "shutdownMember", &_args18, &_result20)
	p.SetLastResponseMeta_(_meta19)
	if _err != nil {
		return
	}
	return _result20.GetSuccess(), nil
}

// Parameters:
//  - ClusterId
//  - MemberId
func (p *RemoteControllerClient) TerminateMember(ctx context.Context, clusterId string, memberId string) (_r bool, _err error) {
	var _args21 RemoteControllerTerminateMemberArgs
	_args21.ClusterId = clusterId
	_args21.MemberId = memberId
	var _result23 RemoteControllerTerminateMemberResult
	var _meta22 thrift.ResponseMeta
	_meta22, _err = p.Client_().Call(ctx, "terminateMember", &_args21, &_result23)
	p.SetLastResponseMeta_(_meta22)
	if _err != nil {
		return
	}
	return _result23.GetSuccess(), nil
}

// Parameters:
//  - ClusterId
//  - MemberId
func (p *RemoteControllerClient) SuspendMember(ctx context.Context, clusterId string, memberId string) (_r bool, _err error) {
	var _args24 RemoteControllerSuspendMemberArgs
	_args24.ClusterId = clusterId
	_args24.MemberId = memberId
	var _result26 RemoteControllerSuspendMemberResult
	var _meta25 thrift.ResponseMeta
	_meta25, _err = p.Client_().Call(ctx, "suspendMember", &_args24, &_result26)
	p.SetLastResponseMeta_(_meta25)
	if _err != nil {
		return
	}
	return _result26.GetSuccess(), nil
}

// Parameters:
//  - ClusterId
//  - MemberId
func (p *RemoteControllerClient) ResumeMember(ctx context.Context, clusterId string, memberId string) (_r bool, _err error) {
	var _args27 RemoteControllerResumeMemberArgs
	_args27.ClusterId = clusterId
	_args27.MemberId = memberId
	var _result29 RemoteControllerResumeMemberResult
	var _meta28 thrift.ResponseMeta
	_meta28, _err = p.Client_().Call(ctx, "resumeMember", &_args27, &_result29)
	p.SetLastResponseMeta_(_meta28)
	if _err != nil {
		return
	}
	return _result29.GetSuccess(), nil
}

// Parameters:
//  - ClusterId
func (p *RemoteControllerClient) ShutdownCluster(ctx context.Context, clusterId string) (_r bool, _err error) {
	var _args30 RemoteControllerShutdownClusterArgs
	_args30.ClusterId = clusterId
	var _result32 RemoteControllerShutdownClusterResult
	var _meta31 thrift.ResponseMeta
	_meta31, _err = p.Client_().Call(ctx, "shutdownCluster", &_args30, &_result32)
	p.SetLastResponseMeta_(_meta31)
	if _err != nil {
		return
	}
	return _result32.GetSuccess(), nil
}

// Parameters:
//  - ClusterId
func (p *RemoteControllerClient) TerminateCluster(ctx context.Context, clusterId string) (_r bool, _err error) {
	var _args33 RemoteControllerTerminateClusterArgs
	_args33.ClusterId = clusterId
	var _result35 RemoteControllerTerminateClusterResult
	var _meta34 thrift.ResponseMeta
	_meta34, _err = p.Client_().Call(ctx, "terminateCluster", &_args33, &_result35)
	p.SetLastResponseMeta_(_meta34)
	if _err != nil {
		return
	}
	return _result35.GetSuccess(), nil
}

// Parameters:
//  - MemberId
func (p *RemoteControllerClient) SplitMemberFromCluster(ctx context.Context, memberId string) (_r *Cluster, _err error) {
	var _args36 RemoteControllerSplitMemberFromClusterArgs
	_args36.MemberId = memberId
	var _result38 RemoteControllerSplitMemberFromClusterResult
	var _meta37 thrift.ResponseMeta
	_meta37, _err = p.Client_().Call(ctx, "splitMemberFromCluster", &_args36, &_result38)
	p.SetLastResponseMeta_(_meta37)
	if _err != nil {
		return
	}
	return _result38.GetSuccess(), nil
}

// Parameters:
//  - ClusterId
//  - MemberId
func (p *RemoteControllerClient) MergeMemberToCluster(ctx context.Context, clusterId string, memberId string) (_r *Cluster, _err error) {
	var _args39 RemoteControllerMergeMemberToClusterArgs
	_args39.ClusterId = clusterId
	_args39.MemberId = memberId
	var _result41 RemoteControllerMergeMemberToClusterResult
	var _meta40 thrift.ResponseMeta
	_meta40, _err = p.Client_().Call(ctx, "mergeMemberToCluster", &_args39, &_result41)
	p.SetLastResponseMeta_(_meta40)
	if _err != nil {
		return
	}
	return _result41.GetSuccess(), nil
}

// Parameters:
//  - ClusterId
//  - Script
//  - Lang
func (p *RemoteControllerClient) ExecuteOnController(ctx context.Context, clusterId string, script string, lang Lang) (_r *Response, _err error) {
	var _args42 RemoteControllerExecuteOnControllerArgs
	_args42.ClusterId = clusterId
	_args42.Script = script
	_args42.Lang = lang
	var _result44 RemoteControllerExecuteOnControllerResult
	var _meta43 thrift.ResponseMeta
	_meta43, _err = p.Client_().Call(ctx, "executeOnController", &_args42, &_result44)
	p.SetLastResponseMeta_(_meta43)
	if _err != nil {
		return
	}
	return _result44.GetSuccess(), nil
}

type RemoteControllerProcessor struct {
	processorMap map[string]thrift.TProcessorFunction
	handler      RemoteController
}

func (p *RemoteControllerProcessor) AddToProcessorMap(key string, processor thrift.TProcessorFunction) {
	p.processorMap[key] = processor
}

func (p *RemoteControllerProcessor) GetProcessorFunction(key string) (processor thrift.TProcessorFunction, ok bool) {
	processor, ok = p.processorMap[key]
	return processor, ok
}

func (p *RemoteControllerProcessor) ProcessorMap() map[string]thrift.TProcessorFunction {
	return p.processorMap
}

func NewRemoteControllerProcessor(handler RemoteController) *RemoteControllerProcessor {

	self45 := &RemoteControllerProcessor{handler: handler, processorMap: make(map[string]thrift.TProcessorFunction)}
	self45.processorMap["ping"] = &remoteControllerProcessorPing{handler: handler}
	self45.processorMap["clean"] = &remoteControllerProcessorClean{handler: handler}
	self45.processorMap["exit"] = &remoteControllerProcessorExit{handler: handler}
	self45.processorMap["createCluster"] = &remoteControllerProcessorCreateCluster{handler: handler}
	self45.processorMap["createClusterKeepClusterName"] = &remoteControllerProcessorCreateClusterKeepClusterName{handler: handler}
	self45.processorMap["startMember"] = &remoteControllerProcessorStartMember{handler: handler}
	self45.processorMap["shutdownMember"] = &remoteControllerProcessorShutdownMember{handler: handler}
	self45.processorMap["terminateMember"] = &remoteControllerProcessorTerminateMember{handler: handler}
	self45.processorMap["suspendMember"] = &remoteControllerProcessorSuspendMember{handler: handler}
	self45.processorMap["resumeMember"] = &remoteControllerProcessorResumeMember{handler: handler}
	self45.processorMap["shutdownCluster"] = &remoteControllerProcessorShutdownCluster{handler: handler}
	self45.processorMap["terminateCluster"] = &remoteControllerProcessorTerminateCluster{handler: handler}
	self45.processorMap["splitMemberFromCluster"] = &remoteControllerProcessorSplitMemberFromCluster{handler: handler}
	self45.processorMap["mergeMemberToCluster"] = &remoteControllerProcessorMergeMemberToCluster{handler: handler}
	self45.processorMap["executeOnController"] = &remoteControllerProcessorExecuteOnController{handler: handler}
	return self45
}

func (p *RemoteControllerProcessor) Process(ctx context.Context, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	name, _, seqId, err2 := iprot.ReadMessageBegin(ctx)
	if err2 != nil {
		return false, thrift.WrapTException(err2)
	}
	if processor, ok := p.GetProcessorFunction(name); ok {
		return processor.Process(ctx, seqId, iprot, oprot)
	}
	iprot.Skip(ctx, thrift.STRUCT)
	iprot.ReadMessageEnd(ctx)
	x46 := thrift.NewTApplicationException(thrift.UNKNOWN_METHOD, "Unknown function "+name)
	oprot.WriteMessageBegin(ctx, name, thrift.EXCEPTION, seqId)
	x46.Write(ctx, oprot)
	oprot.WriteMessageEnd(ctx)
	oprot.Flush(ctx)
	return false, x46

}

type remoteControllerProcessorPing struct {
	handler RemoteController
}

func (p *remoteControllerProcessorPing) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := RemoteControllerPingArgs{}
	var err2 error
	if err2 = args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "ping", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithCancel(ctx)
		defer cancel()
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel()
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := RemoteControllerPingResult{}
	var retval bool
	if retval, err2 = p.handler.Ping(ctx); err2 != nil {
		tickerCancel()
		if err2 == thrift.ErrAbandonRequest {
			return false, thrift.WrapTException(err2)
		}
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing ping: "+err2.Error())
		oprot.WriteMessageBegin(ctx, "ping", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return true, thrift.WrapTException(err2)
	} else {
		result.Success = &retval
	}
	tickerCancel()
	if err2 = oprot.WriteMessageBegin(ctx, "ping", thrift.REPLY, seqId); err2 != nil {
		err = thrift.WrapTException(err2)
	}
	if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
		err = thrift.WrapTException(err2)
	}
	if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
		err = thrift.WrapTException(err2)
	}
	if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
		err = thrift.WrapTException(err2)
	}
	if err != nil {
		return
	}
	return true, err
}

type remoteControllerProcessorClean struct {
	handler RemoteController
}

func (p *remoteControllerProcessorClean) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := RemoteControllerCleanArgs{}
	var err2 error
	if err2 = args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "clean", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithCancel(ctx)
		defer cancel()
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel()
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := RemoteControllerCleanResult{}
	var retval bool
	if retval, err2 = p.handler.Clean(ctx); err2 != nil {
		tickerCancel()
		if err2 == thrift.ErrAbandonRequest {
			return false, thrift.WrapTException(err2)
		}
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing clean: "+err2.Error())
		oprot.WriteMessageBegin(ctx, "clean", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return true, thrift.WrapTException(err2)
	} else {
		result.Success = &retval
	}
	tickerCancel()
	if err2 = oprot.WriteMessageBegin(ctx, "clean", thrift.REPLY, seqId); err2 != nil {
		err = thrift.WrapTException(err2)
	}
	if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
		err = thrift.WrapTException(err2)
	}
	if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
		err = thrift.WrapTException(err2)
	}
	if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
		err = thrift.WrapTException(err2)
	}
	if err != nil {
		return
	}
	return true, err
}

type remoteControllerProcessorExit struct {
	handler RemoteController
}

func (p *remoteControllerProcessorExit) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := RemoteControllerExitArgs{}
	var err2 error
	if err2 = args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "exit", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithCancel(ctx)
		defer cancel()
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel()
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := RemoteControllerExitResult{}
	var retval bool
	if retval, err2 = p.handler.Exit(ctx); err2 != nil {
		tickerCancel()
		if err2 == thrift.ErrAbandonRequest {
			return false, thrift.WrapTException(err2)
		}
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing exit: "+err2.Error())
		oprot.WriteMessageBegin(ctx, "exit", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return true, thrift.WrapTException(err2)
	} else {
		result.Success = &retval
	}
	tickerCancel()
	if err2 = oprot.WriteMessageBegin(ctx, "exit", thrift.REPLY, seqId); err2 != nil {
		err = thrift.WrapTException(err2)
	}
	if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
		err = thrift.WrapTException(err2)
	}
	if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
		err = thrift.WrapTException(err2)
	}
	if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
		err = thrift.WrapTException(err2)
	}
	if err != nil {
		return
	}
	return true, err
}

type remoteControllerProcessorCreateCluster struct {
	handler RemoteController
}

func (p *remoteControllerProcessorCreateCluster) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := RemoteControllerCreateClusterArgs{}
	var err2 error
	if err2 = args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "createCluster", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithCancel(ctx)
		defer cancel()
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel()
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := RemoteControllerCreateClusterResult{}
	var retval *Cluster
	if retval, err2 = p.handler.CreateCluster(ctx, args.HzVersion, args.Xmlconfig); err2 != nil {
		tickerCancel()
		switch v := err2.(type) {
		case *ServerException:
			result.ServerException = v
		default:
			if err2 == thrift.ErrAbandonRequest {
				return false, thrift.WrapTException(err2)
			}
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing createCluster: "+err2.Error())
			oprot.WriteMessageBegin(ctx, "createCluster", thrift.EXCEPTION, seqId)
			x.Write(ctx, oprot)
			oprot.WriteMessageEnd(ctx)
			oprot.Flush(ctx)
			return true, thrift.WrapTException(err2)
		}
	} else {
		result.Success = retval
	}
	tickerCancel()
	if err2 = oprot.WriteMessageBegin(ctx, "createCluster", thrift.REPLY, seqId); err2 != nil {
		err = thrift.WrapTException(err2)
	}
	if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
		err = thrift.WrapTException(err2)
	}
	if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
		err = thrift.WrapTException(err2)
	}
	if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
		err = thrift.WrapTException(err2)
	}
	if err != nil {
		return
	}
	return true, err
}

type remoteControllerProcessorCreateClusterKeepClusterName struct {
	handler RemoteController
}

func (p *remoteControllerProcessorCreateClusterKeepClusterName) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := RemoteControllerCreateClusterKeepClusterNameArgs{}
	var err2 error
	if err2 = args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "createClusterKeepClusterName", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithCancel(ctx)
		defer cancel()
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel()
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := RemoteControllerCreateClusterKeepClusterNameResult{}
	var retval *Cluster
	if retval, err2 = p.handler.CreateClusterKeepClusterName(ctx, args.HzVersion, args.Xmlconfig); err2 != nil {
		tickerCancel()
		switch v := err2.(type) {
		case *ServerException:
			result.ServerException = v
		default:
			if err2 == thrift.ErrAbandonRequest {
				return false, thrift.WrapTException(err2)
			}
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing createClusterKeepClusterName: "+err2.Error())
			oprot.WriteMessageBegin(ctx, "createClusterKeepClusterName", thrift.EXCEPTION, seqId)
			x.Write(ctx, oprot)
			oprot.WriteMessageEnd(ctx)
			oprot.Flush(ctx)
			return true, thrift.WrapTException(err2)
		}
	} else {
		result.Success = retval
	}
	tickerCancel()
	if err2 = oprot.WriteMessageBegin(ctx, "createClusterKeepClusterName", thrift.REPLY, seqId); err2 != nil {
		err = thrift.WrapTException(err2)
	}
	if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
		err = thrift.WrapTException(err2)
	}
	if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
		err = thrift.WrapTException(err2)
	}
	if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
		err = thrift.WrapTException(err2)
	}
	if err != nil {
		return
	}
	return true, err
}

type remoteControllerProcessorStartMember struct {
	handler RemoteController
}

func (p *remoteControllerProcessorStartMember) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := RemoteControllerStartMemberArgs{}
	var err2 error
	if err2 = args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "startMember", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithCancel(ctx)
		defer cancel()
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel()
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := RemoteControllerStartMemberResult{}
	var retval *Member
	if retval, err2 = p.handler.StartMember(ctx, args.ClusterId); err2 != nil {
		tickerCancel()
		switch v := err2.(type) {
		case *ServerException:
			result.ServerException = v
		default:
			if err2 == thrift.ErrAbandonRequest {
				return false, thrift.WrapTException(err2)
			}
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing startMember: "+err2.Error())
			oprot.WriteMessageBegin(ctx, "startMember", thrift.EXCEPTION, seqId)
			x.Write(ctx, oprot)
			oprot.WriteMessageEnd(ctx)
			oprot.Flush(ctx)
			return true, thrift.WrapTException(err2)
		}
	} else {
		result.Success = retval
	}
	tickerCancel()
	if err2 = oprot.WriteMessageBegin(ctx, "startMember", thrift.REPLY, seqId); err2 != nil {
		err = thrift.WrapTException(err2)
	}
	if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
		err = thrift.WrapTException(err2)
	}
	if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
		err = thrift.WrapTException(err2)
	}
	if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
		err = thrift.WrapTException(err2)
	}
	if err != nil {
		return
	}
	return true, err
}

type remoteControllerProcessorShutdownMember struct {
	handler RemoteController
}

func (p *remoteControllerProcessorShutdownMember) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := RemoteControllerShutdownMemberArgs{}
	var err2 error
	if err2 = args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "shutdownMember", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithCancel(ctx)
		defer cancel()
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel()
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := RemoteControllerShutdownMemberResult{}
	var retval bool
	if retval, err2 = p.handler.ShutdownMember(ctx, args.ClusterId, args.MemberId); err2 != nil {
		tickerCancel()
		if err2 == thrift.ErrAbandonRequest {
			return false, thrift.WrapTException(err2)
		}
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing shutdownMember: "+err2.Error())
		oprot.WriteMessageBegin(ctx, "shutdownMember", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return true, thrift.WrapTException(err2)
	} else {
		result.Success = &retval
	}
	tickerCancel()
	if err2 = oprot.WriteMessageBegin(ctx, "shutdownMember", thrift.REPLY, seqId); err2 != nil {
		err = thrift.WrapTException(err2)
	}
	if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
		err = thrift.WrapTException(err2)
	}
	if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
		err = thrift.WrapTException(err2)
	}
	if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
		err = thrift.WrapTException(err2)
	}
	if err != nil {
		return
	}
	return true, err
}

type remoteControllerProcessorTerminateMember struct {
	handler RemoteController
}

func (p *remoteControllerProcessorTerminateMember) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := RemoteControllerTerminateMemberArgs{}
	var err2 error
	if err2 = args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "terminateMember", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithCancel(ctx)
		defer cancel()
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel()
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := RemoteControllerTerminateMemberResult{}
	var retval bool
	if retval, err2 = p.handler.TerminateMember(ctx, args.ClusterId, args.MemberId); err2 != nil {
		tickerCancel()
		if err2 == thrift.ErrAbandonRequest {
			return false, thrift.WrapTException(err2)
		}
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing terminateMember: "+err2.Error())
		oprot.WriteMessageBegin(ctx, "terminateMember", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return true, thrift.WrapTException(err2)
	} else {
		result.Success = &retval
	}
	tickerCancel()
	if err2 = oprot.WriteMessageBegin(ctx, "terminateMember", thrift.REPLY, seqId); err2 != nil {
		err = thrift.WrapTException(err2)
	}
	if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
		err = thrift.WrapTException(err2)
	}
	if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
		err = thrift.WrapTException(err2)
	}
	if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
		err = thrift.WrapTException(err2)
	}
	if err != nil {
		return
	}
	return true, err
}

type remoteControllerProcessorSuspendMember struct {
	handler RemoteController
}

func (p *remoteControllerProcessorSuspendMember) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := RemoteControllerSuspendMemberArgs{}
	var err2 error
	if err2 = args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "suspendMember", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithCancel(ctx)
		defer cancel()
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel()
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := RemoteControllerSuspendMemberResult{}
	var retval bool
	if retval, err2 = p.handler.SuspendMember(ctx, args.ClusterId, args.MemberId); err2 != nil {
		tickerCancel()
		if err2 == thrift.ErrAbandonRequest {
			return false, thrift.WrapTException(err2)
		}
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing suspendMember: "+err2.Error())
		oprot.WriteMessageBegin(ctx, "suspendMember", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return true, thrift.WrapTException(err2)
	} else {
		result.Success = &retval
	}
	tickerCancel()
	if err2 = oprot.WriteMessageBegin(ctx, "suspendMember", thrift.REPLY, seqId); err2 != nil {
		err = thrift.WrapTException(err2)
	}
	if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
		err = thrift.WrapTException(err2)
	}
	if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
		err = thrift.WrapTException(err2)
	}
	if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
		err = thrift.WrapTException(err2)
	}
	if err != nil {
		return
	}
	return true, err
}

type remoteControllerProcessorResumeMember struct {
	handler RemoteController
}

func (p *remoteControllerProcessorResumeMember) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := RemoteControllerResumeMemberArgs{}
	var err2 error
	if err2 = args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "resumeMember", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithCancel(ctx)
		defer cancel()
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel()
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := RemoteControllerResumeMemberResult{}
	var retval bool
	if retval, err2 = p.handler.ResumeMember(ctx, args.ClusterId, args.MemberId); err2 != nil {
		tickerCancel()
		if err2 == thrift.ErrAbandonRequest {
			return false, thrift.WrapTException(err2)
		}
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing resumeMember: "+err2.Error())
		oprot.WriteMessageBegin(ctx, "resumeMember", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return true, thrift.WrapTException(err2)
	} else {
		result.Success = &retval
	}
	tickerCancel()
	if err2 = oprot.WriteMessageBegin(ctx, "resumeMember", thrift.REPLY, seqId); err2 != nil {
		err = thrift.WrapTException(err2)
	}
	if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
		err = thrift.WrapTException(err2)
	}
	if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
		err = thrift.WrapTException(err2)
	}
	if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
		err = thrift.WrapTException(err2)
	}
	if err != nil {
		return
	}
	return true, err
}

type remoteControllerProcessorShutdownCluster struct {
	handler RemoteController
}

func (p *remoteControllerProcessorShutdownCluster) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := RemoteControllerShutdownClusterArgs{}
	var err2 error
	if err2 = args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "shutdownCluster", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithCancel(ctx)
		defer cancel()
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel()
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := RemoteControllerShutdownClusterResult{}
	var retval bool
	if retval, err2 = p.handler.ShutdownCluster(ctx, args.ClusterId); err2 != nil {
		tickerCancel()
		if err2 == thrift.ErrAbandonRequest {
			return false, thrift.WrapTException(err2)
		}
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing shutdownCluster: "+err2.Error())
		oprot.WriteMessageBegin(ctx, "shutdownCluster", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return true, thrift.WrapTException(err2)
	} else {
		result.Success = &retval
	}
	tickerCancel()
	if err2 = oprot.WriteMessageBegin(ctx, "shutdownCluster", thrift.REPLY, seqId); err2 != nil {
		err = thrift.WrapTException(err2)
	}
	if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
		err = thrift.WrapTException(err2)
	}
	if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
		err = thrift.WrapTException(err2)
	}
	if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
		err = thrift.WrapTException(err2)
	}
	if err != nil {
		return
	}
	return true, err
}

type remoteControllerProcessorTerminateCluster struct {
	handler RemoteController
}

func (p *remoteControllerProcessorTerminateCluster) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := RemoteControllerTerminateClusterArgs{}
	var err2 error
	if err2 = args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "terminateCluster", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithCancel(ctx)
		defer cancel()
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel()
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := RemoteControllerTerminateClusterResult{}
	var retval bool
	if retval, err2 = p.handler.TerminateCluster(ctx, args.ClusterId); err2 != nil {
		tickerCancel()
		if err2 == thrift.ErrAbandonRequest {
			return false, thrift.WrapTException(err2)
		}
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing terminateCluster: "+err2.Error())
		oprot.WriteMessageBegin(ctx, "terminateCluster", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return true, thrift.WrapTException(err2)
	} else {
		result.Success = &retval
	}
	tickerCancel()
	if err2 = oprot.WriteMessageBegin(ctx, "terminateCluster", thrift.REPLY, seqId); err2 != nil {
		err = thrift.WrapTException(err2)
	}
	if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
		err = thrift.WrapTException(err2)
	}
	if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
		err = thrift.WrapTException(err2)
	}
	if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
		err = thrift.WrapTException(err2)
	}
	if err != nil {
		return
	}
	return true, err
}

type remoteControllerProcessorSplitMemberFromCluster struct {
	handler RemoteController
}

func (p *remoteControllerProcessorSplitMemberFromCluster) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := RemoteControllerSplitMemberFromClusterArgs{}
	var err2 error
	if err2 = args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "splitMemberFromCluster", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithCancel(ctx)
		defer cancel()
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel()
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := RemoteControllerSplitMemberFromClusterResult{}
	var retval *Cluster
	if retval, err2 = p.handler.SplitMemberFromCluster(ctx, args.MemberId); err2 != nil {
		tickerCancel()
		if err2 == thrift.ErrAbandonRequest {
			return false, thrift.WrapTException(err2)
		}
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing splitMemberFromCluster: "+err2.Error())
		oprot.WriteMessageBegin(ctx, "splitMemberFromCluster", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return true, thrift.WrapTException(err2)
	} else {
		result.Success = retval
	}
	tickerCancel()
	if err2 = oprot.WriteMessageBegin(ctx, "splitMemberFromCluster", thrift.REPLY, seqId); err2 != nil {
		err = thrift.WrapTException(err2)
	}
	if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
		err = thrift.WrapTException(err2)
	}
	if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
		err = thrift.WrapTException(err2)
	}
	if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
		err = thrift.WrapTException(err2)
	}
	if err != nil {
		return
	}
	return true, err
}

type remoteControllerProcessorMergeMemberToCluster struct {
	handler RemoteController
}

func (p *remoteControllerProcessorMergeMemberToCluster) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := RemoteControllerMergeMemberToClusterArgs{}
	var err2 error
	if err2 = args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "mergeMemberToCluster", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithCancel(ctx)
		defer cancel()
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel()
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := RemoteControllerMergeMemberToClusterResult{}
	var retval *Cluster
	if retval, err2 = p.handler.MergeMemberToCluster(ctx, args.ClusterId, args.MemberId); err2 != nil {
		tickerCancel()
		if err2 == thrift.ErrAbandonRequest {
			return false, thrift.WrapTException(err2)
		}
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing mergeMemberToCluster: "+err2.Error())
		oprot.WriteMessageBegin(ctx, "mergeMemberToCluster", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return true, thrift.WrapTException(err2)
	} else {
		result.Success = retval
	}
	tickerCancel()
	if err2 = oprot.WriteMessageBegin(ctx, "mergeMemberToCluster", thrift.REPLY, seqId); err2 != nil {
		err = thrift.WrapTException(err2)
	}
	if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
		err = thrift.WrapTException(err2)
	}
	if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
		err = thrift.WrapTException(err2)
	}
	if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
		err = thrift.WrapTException(err2)
	}
	if err != nil {
		return
	}
	return true, err
}

type remoteControllerProcessorExecuteOnController struct {
	handler RemoteController
}

func (p *remoteControllerProcessorExecuteOnController) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := RemoteControllerExecuteOnControllerArgs{}
	var err2 error
	if err2 = args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "executeOnController", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithCancel(ctx)
		defer cancel()
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel()
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := RemoteControllerExecuteOnControllerResult{}
	var retval *Response
	if retval, err2 = p.handler.ExecuteOnController(ctx, args.ClusterId, args.Script, args.Lang); err2 != nil {
		tickerCancel()
		if err2 == thrift.ErrAbandonRequest {
			return false, thrift.WrapTException(err2)
		}
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing executeOnController: "+err2.Error())
		oprot.WriteMessageBegin(ctx, "executeOnController", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return true, thrift.WrapTException(err2)
	} else {
		result.Success = retval
	}
	tickerCancel()
	if err2 = oprot.WriteMessageBegin(ctx, "executeOnController", thrift.REPLY, seqId); err2 != nil {
		err = thrift.WrapTException(err2)
	}
	if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
		err = thrift.WrapTException(err2)
	}
	if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
		err = thrift.WrapTException(err2)
	}
	if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
		err = thrift.WrapTException(err2)
	}
	if err != nil {
		return
	}
	return true, err
}

// HELPER FUNCTIONS AND STRUCTURES

type RemoteControllerPingArgs struct {
}

func NewRemoteControllerPingArgs() *RemoteControllerPingArgs {
	return &RemoteControllerPingArgs{}
}

func (p *RemoteControllerPingArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.Skip(ctx, fieldTypeId); err != nil {
			return err
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *RemoteControllerPingArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "ping_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *RemoteControllerPingArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("RemoteControllerPingArgs(%+v)", *p)
}

// Attributes:
//  - Success
type RemoteControllerPingResult struct {
	Success *bool `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewRemoteControllerPingResult() *RemoteControllerPingResult {
	return &RemoteControllerPingResult{}
}

var RemoteControllerPingResult_Success_DEFAULT bool

func (p *RemoteControllerPingResult) GetSuccess() bool {
	if !p.IsSetSuccess() {
		return RemoteControllerPingResult_Success_DEFAULT
	}
	return *p.Success
}
func (p *RemoteControllerPingResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *RemoteControllerPingResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.BOOL {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *RemoteControllerPingResult) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(ctx); err != nil {
		return thrift.PrependError("error reading field 0: ", err)
	} else {
		p.Success = &v
	}
	return nil
}

func (p *RemoteControllerPingResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "ping_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *RemoteControllerPingResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.BOOL, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := oprot.WriteBool(ctx, bool(*p.Success)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *RemoteControllerPingResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("RemoteControllerPingResult(%+v)", *p)
}

type RemoteControllerCleanArgs struct {
}

func NewRemoteControllerCleanArgs() *RemoteControllerCleanArgs {
	return &RemoteControllerCleanArgs{}
}

func (p *RemoteControllerCleanArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.Skip(ctx, fieldTypeId); err != nil {
			return err
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *RemoteControllerCleanArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "clean_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *RemoteControllerCleanArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("RemoteControllerCleanArgs(%+v)", *p)
}

// Attributes:
//  - Success
type RemoteControllerCleanResult struct {
	Success *bool `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewRemoteControllerCleanResult() *RemoteControllerCleanResult {
	return &RemoteControllerCleanResult{}
}

var RemoteControllerCleanResult_Success_DEFAULT bool

func (p *RemoteControllerCleanResult) GetSuccess() bool {
	if !p.IsSetSuccess() {
		return RemoteControllerCleanResult_Success_DEFAULT
	}
	return *p.Success
}
func (p *RemoteControllerCleanResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *RemoteControllerCleanResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.BOOL {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *RemoteControllerCleanResult) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(ctx); err != nil {
		return thrift.PrependError("error reading field 0: ", err)
	} else {
		p.Success = &v
	}
	return nil
}

func (p *RemoteControllerCleanResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "clean_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *RemoteControllerCleanResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.BOOL, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := oprot.WriteBool(ctx, bool(*p.Success)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *RemoteControllerCleanResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("RemoteControllerCleanResult(%+v)", *p)
}

type RemoteControllerExitArgs struct {
}

func NewRemoteControllerExitArgs() *RemoteControllerExitArgs {
	return &RemoteControllerExitArgs{}
}

func (p *RemoteControllerExitArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.Skip(ctx, fieldTypeId); err != nil {
			return err
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *RemoteControllerExitArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "exit_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *RemoteControllerExitArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("RemoteControllerExitArgs(%+v)", *p)
}

// Attributes:
//  - Success
type RemoteControllerExitResult struct {
	Success *bool `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewRemoteControllerExitResult() *RemoteControllerExitResult {
	return &RemoteControllerExitResult{}
}

var RemoteControllerExitResult_Success_DEFAULT bool

func (p *RemoteControllerExitResult) GetSuccess() bool {
	if !p.IsSetSuccess() {
		return RemoteControllerExitResult_Success_DEFAULT
	}
	return *p.Success
}
func (p *RemoteControllerExitResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *RemoteControllerExitResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.BOOL {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *RemoteControllerExitResult) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(ctx); err != nil {
		return thrift.PrependError("error reading field 0: ", err)
	} else {
		p.Success = &v
	}
	return nil
}

func (p *RemoteControllerExitResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "exit_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *RemoteControllerExitResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.BOOL, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := oprot.WriteBool(ctx, bool(*p.Success)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *RemoteControllerExitResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("RemoteControllerExitResult(%+v)", *p)
}

// Attributes:
//  - HzVersion
//  - Xmlconfig
type RemoteControllerCreateClusterArgs struct {
	HzVersion string `thrift:"hzVersion,1" db:"hzVersion" json:"hzVersion"`
	Xmlconfig string `thrift:"xmlconfig,2" db:"xmlconfig" json:"xmlconfig"`
}

func NewRemoteControllerCreateClusterArgs() *RemoteControllerCreateClusterArgs {
	return &RemoteControllerCreateClusterArgs{}
}

func (p *RemoteControllerCreateClusterArgs) GetHzVersion() string {
	return p.HzVersion
}

func (p *RemoteControllerCreateClusterArgs) GetXmlconfig() string {
	return p.Xmlconfig
}
func (p *RemoteControllerCreateClusterArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *RemoteControllerCreateClusterArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.HzVersion = v
	}
	return nil
}

func (p *RemoteControllerCreateClusterArgs) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.Xmlconfig = v
	}
	return nil
}

func (p *RemoteControllerCreateClusterArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "createCluster_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *RemoteControllerCreateClusterArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "hzVersion", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:hzVersion: ", p), err)
	}
	if err := oprot.WriteString(ctx, string(p.HzVersion)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.hzVersion (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:hzVersion: ", p), err)
	}
	return err
}

func (p *RemoteControllerCreateClusterArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "xmlconfig", thrift.STRING, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:xmlconfig: ", p), err)
	}
	if err := oprot.WriteString(ctx, string(p.Xmlconfig)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.xmlconfig (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:xmlconfig: ", p), err)
	}
	return err
}

func (p *RemoteControllerCreateClusterArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("RemoteControllerCreateClusterArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - ServerException
type RemoteControllerCreateClusterResult struct {
	Success         *Cluster         `thrift:"success,0" db:"success" json:"success,omitempty"`
	ServerException *ServerException `thrift:"serverException,1" db:"serverException" json:"serverException,omitempty"`
}

func NewRemoteControllerCreateClusterResult() *RemoteControllerCreateClusterResult {
	return &RemoteControllerCreateClusterResult{}
}

var RemoteControllerCreateClusterResult_Success_DEFAULT *Cluster

func (p *RemoteControllerCreateClusterResult) GetSuccess() *Cluster {
	if !p.IsSetSuccess() {
		return RemoteControllerCreateClusterResult_Success_DEFAULT
	}
	return p.Success
}

var RemoteControllerCreateClusterResult_ServerException_DEFAULT *ServerException

func (p *RemoteControllerCreateClusterResult) GetServerException() *ServerException {
	if !p.IsSetServerException() {
		return RemoteControllerCreateClusterResult_ServerException_DEFAULT
	}
	return p.ServerException
}
func (p *RemoteControllerCreateClusterResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *RemoteControllerCreateClusterResult) IsSetServerException() bool {
	return p.ServerException != nil
}

func (p *RemoteControllerCreateClusterResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *RemoteControllerCreateClusterResult) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	p.Success = &Cluster{}
	if err := p.Success.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *RemoteControllerCreateClusterResult) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.ServerException = &ServerException{}
	if err := p.ServerException.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.ServerException), err)
	}
	return nil
}

func (p *RemoteControllerCreateClusterResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "createCluster_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *RemoteControllerCreateClusterResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *RemoteControllerCreateClusterResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetServerException() {
		if err := oprot.WriteFieldBegin(ctx, "serverException", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:serverException: ", p), err)
		}
		if err := p.ServerException.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.ServerException), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:serverException: ", p), err)
		}
	}
	return err
}

func (p *RemoteControllerCreateClusterResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("RemoteControllerCreateClusterResult(%+v)", *p)
}

// Attributes:
//  - HzVersion
//  - Xmlconfig
type RemoteControllerCreateClusterKeepClusterNameArgs struct {
	HzVersion string `thrift:"hzVersion,1" db:"hzVersion" json:"hzVersion"`
	Xmlconfig string `thrift:"xmlconfig,2" db:"xmlconfig" json:"xmlconfig"`
}

func NewRemoteControllerCreateClusterKeepClusterNameArgs() *RemoteControllerCreateClusterKeepClusterNameArgs {
	return &RemoteControllerCreateClusterKeepClusterNameArgs{}
}

func (p *RemoteControllerCreateClusterKeepClusterNameArgs) GetHzVersion() string {
	return p.HzVersion
}

func (p *RemoteControllerCreateClusterKeepClusterNameArgs) GetXmlconfig() string {
	return p.Xmlconfig
}
func (p *RemoteControllerCreateClusterKeepClusterNameArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *RemoteControllerCreateClusterKeepClusterNameArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.HzVersion = v
	}
	return nil
}

func (p *RemoteControllerCreateClusterKeepClusterNameArgs) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.Xmlconfig = v
	}
	return nil
}

func (p *RemoteControllerCreateClusterKeepClusterNameArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "createClusterKeepClusterName_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *RemoteControllerCreateClusterKeepClusterNameArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "hzVersion", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:hzVersion: ", p), err)
	}
	if err := oprot.WriteString(ctx, string(p.HzVersion)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.hzVersion (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:hzVersion: ", p), err)
	}
	return err
}

func (p *RemoteControllerCreateClusterKeepClusterNameArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "xmlconfig", thrift.STRING, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:xmlconfig: ", p), err)
	}
	if err := oprot.WriteString(ctx, string(p.Xmlconfig)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.xmlconfig (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:xmlconfig: ", p), err)
	}
	return err
}

func (p *RemoteControllerCreateClusterKeepClusterNameArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("RemoteControllerCreateClusterKeepClusterNameArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - ServerException
type RemoteControllerCreateClusterKeepClusterNameResult struct {
	Success         *Cluster         `thrift:"success,0" db:"success" json:"success,omitempty"`
	ServerException *ServerException `thrift:"serverException,1" db:"serverException" json:"serverException,omitempty"`
}

func NewRemoteControllerCreateClusterKeepClusterNameResult() *RemoteControllerCreateClusterKeepClusterNameResult {
	return &RemoteControllerCreateClusterKeepClusterNameResult{}
}

var RemoteControllerCreateClusterKeepClusterNameResult_Success_DEFAULT *Cluster

func (p *RemoteControllerCreateClusterKeepClusterNameResult) GetSuccess() *Cluster {
	if !p.IsSetSuccess() {
		return RemoteControllerCreateClusterKeepClusterNameResult_Success_DEFAULT
	}
	return p.Success
}

var RemoteControllerCreateClusterKeepClusterNameResult_ServerException_DEFAULT *ServerException

func (p *RemoteControllerCreateClusterKeepClusterNameResult) GetServerException() *ServerException {
	if !p.IsSetServerException() {
		return RemoteControllerCreateClusterKeepClusterNameResult_ServerException_DEFAULT
	}
	return p.ServerException
}
func (p *RemoteControllerCreateClusterKeepClusterNameResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *RemoteControllerCreateClusterKeepClusterNameResult) IsSetServerException() bool {
	return p.ServerException != nil
}

func (p *RemoteControllerCreateClusterKeepClusterNameResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *RemoteControllerCreateClusterKeepClusterNameResult) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	p.Success = &Cluster{}
	if err := p.Success.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *RemoteControllerCreateClusterKeepClusterNameResult) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.ServerException = &ServerException{}
	if err := p.ServerException.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.ServerException), err)
	}
	return nil
}

func (p *RemoteControllerCreateClusterKeepClusterNameResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "createClusterKeepClusterName_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *RemoteControllerCreateClusterKeepClusterNameResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *RemoteControllerCreateClusterKeepClusterNameResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetServerException() {
		if err := oprot.WriteFieldBegin(ctx, "serverException", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:serverException: ", p), err)
		}
		if err := p.ServerException.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.ServerException), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:serverException: ", p), err)
		}
	}
	return err
}

func (p *RemoteControllerCreateClusterKeepClusterNameResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("RemoteControllerCreateClusterKeepClusterNameResult(%+v)", *p)
}

// Attributes:
//  - ClusterId
type RemoteControllerStartMemberArgs struct {
	ClusterId string `thrift:"clusterId,1" db:"clusterId" json:"clusterId"`
}

func NewRemoteControllerStartMemberArgs() *RemoteControllerStartMemberArgs {
	return &RemoteControllerStartMemberArgs{}
}

func (p *RemoteControllerStartMemberArgs) GetClusterId() string {
	return p.ClusterId
}
func (p *RemoteControllerStartMemberArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *RemoteControllerStartMemberArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.ClusterId = v
	}
	return nil
}

func (p *RemoteControllerStartMemberArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "startMember_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *RemoteControllerStartMemberArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "clusterId", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:clusterId: ", p), err)
	}
	if err := oprot.WriteString(ctx, string(p.ClusterId)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.clusterId (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:clusterId: ", p), err)
	}
	return err
}

func (p *RemoteControllerStartMemberArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("RemoteControllerStartMemberArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - ServerException
type RemoteControllerStartMemberResult struct {
	Success         *Member          `thrift:"success,0" db:"success" json:"success,omitempty"`
	ServerException *ServerException `thrift:"serverException,1" db:"serverException" json:"serverException,omitempty"`
}

func NewRemoteControllerStartMemberResult() *RemoteControllerStartMemberResult {
	return &RemoteControllerStartMemberResult{}
}

var RemoteControllerStartMemberResult_Success_DEFAULT *Member

func (p *RemoteControllerStartMemberResult) GetSuccess() *Member {
	if !p.IsSetSuccess() {
		return RemoteControllerStartMemberResult_Success_DEFAULT
	}
	return p.Success
}

var RemoteControllerStartMemberResult_ServerException_DEFAULT *ServerException

func (p *RemoteControllerStartMemberResult) GetServerException() *ServerException {
	if !p.IsSetServerException() {
		return RemoteControllerStartMemberResult_ServerException_DEFAULT
	}
	return p.ServerException
}
func (p *RemoteControllerStartMemberResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *RemoteControllerStartMemberResult) IsSetServerException() bool {
	return p.ServerException != nil
}

func (p *RemoteControllerStartMemberResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *RemoteControllerStartMemberResult) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	p.Success = &Member{}
	if err := p.Success.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *RemoteControllerStartMemberResult) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.ServerException = &ServerException{}
	if err := p.ServerException.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.ServerException), err)
	}
	return nil
}

func (p *RemoteControllerStartMemberResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "startMember_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *RemoteControllerStartMemberResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *RemoteControllerStartMemberResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetServerException() {
		if err := oprot.WriteFieldBegin(ctx, "serverException", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:serverException: ", p), err)
		}
		if err := p.ServerException.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.ServerException), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:serverException: ", p), err)
		}
	}
	return err
}

func (p *RemoteControllerStartMemberResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("RemoteControllerStartMemberResult(%+v)", *p)
}

// Attributes:
//  - ClusterId
//  - MemberId
type RemoteControllerShutdownMemberArgs struct {
	ClusterId string `thrift:"clusterId,1" db:"clusterId" json:"clusterId"`
	MemberId  string `thrift:"memberId,2" db:"memberId" json:"memberId"`
}

func NewRemoteControllerShutdownMemberArgs() *RemoteControllerShutdownMemberArgs {
	return &RemoteControllerShutdownMemberArgs{}
}

func (p *RemoteControllerShutdownMemberArgs) GetClusterId() string {
	return p.ClusterId
}

func (p *RemoteControllerShutdownMemberArgs) GetMemberId() string {
	return p.MemberId
}
func (p *RemoteControllerShutdownMemberArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *RemoteControllerShutdownMemberArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.ClusterId = v
	}
	return nil
}

func (p *RemoteControllerShutdownMemberArgs) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.MemberId = v
	}
	return nil
}

func (p *RemoteControllerShutdownMemberArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "shutdownMember_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *RemoteControllerShutdownMemberArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "clusterId", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:clusterId: ", p), err)
	}
	if err := oprot.WriteString(ctx, string(p.ClusterId)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.clusterId (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:clusterId: ", p), err)
	}
	return err
}

func (p *RemoteControllerShutdownMemberArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "memberId", thrift.STRING, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:memberId: ", p), err)
	}
	if err := oprot.WriteString(ctx, string(p.MemberId)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.memberId (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:memberId: ", p), err)
	}
	return err
}

func (p *RemoteControllerShutdownMemberArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("RemoteControllerShutdownMemberArgs(%+v)", *p)
}

// Attributes:
//  - Success
type RemoteControllerShutdownMemberResult struct {
	Success *bool `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewRemoteControllerShutdownMemberResult() *RemoteControllerShutdownMemberResult {
	return &RemoteControllerShutdownMemberResult{}
}

var RemoteControllerShutdownMemberResult_Success_DEFAULT bool

func (p *RemoteControllerShutdownMemberResult) GetSuccess() bool {
	if !p.IsSetSuccess() {
		return RemoteControllerShutdownMemberResult_Success_DEFAULT
	}
	return *p.Success
}
func (p *RemoteControllerShutdownMemberResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *RemoteControllerShutdownMemberResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.BOOL {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *RemoteControllerShutdownMemberResult) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(ctx); err != nil {
		return thrift.PrependError("error reading field 0: ", err)
	} else {
		p.Success = &v
	}
	return nil
}

func (p *RemoteControllerShutdownMemberResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "shutdownMember_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *RemoteControllerShutdownMemberResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.BOOL, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := oprot.WriteBool(ctx, bool(*p.Success)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *RemoteControllerShutdownMemberResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("RemoteControllerShutdownMemberResult(%+v)", *p)
}

// Attributes:
//  - ClusterId
//  - MemberId
type RemoteControllerTerminateMemberArgs struct {
	ClusterId string `thrift:"clusterId,1" db:"clusterId" json:"clusterId"`
	MemberId  string `thrift:"memberId,2" db:"memberId" json:"memberId"`
}

func NewRemoteControllerTerminateMemberArgs() *RemoteControllerTerminateMemberArgs {
	return &RemoteControllerTerminateMemberArgs{}
}

func (p *RemoteControllerTerminateMemberArgs) GetClusterId() string {
	return p.ClusterId
}

func (p *RemoteControllerTerminateMemberArgs) GetMemberId() string {
	return p.MemberId
}
func (p *RemoteControllerTerminateMemberArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *RemoteControllerTerminateMemberArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.ClusterId = v
	}
	return nil
}

func (p *RemoteControllerTerminateMemberArgs) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.MemberId = v
	}
	return nil
}

func (p *RemoteControllerTerminateMemberArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "terminateMember_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *RemoteControllerTerminateMemberArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "clusterId", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:clusterId: ", p), err)
	}
	if err := oprot.WriteString(ctx, string(p.ClusterId)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.clusterId (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:clusterId: ", p), err)
	}
	return err
}

func (p *RemoteControllerTerminateMemberArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "memberId", thrift.STRING, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:memberId: ", p), err)
	}
	if err := oprot.WriteString(ctx, string(p.MemberId)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.memberId (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:memberId: ", p), err)
	}
	return err
}

func (p *RemoteControllerTerminateMemberArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("RemoteControllerTerminateMemberArgs(%+v)", *p)
}

// Attributes:
//  - Success
type RemoteControllerTerminateMemberResult struct {
	Success *bool `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewRemoteControllerTerminateMemberResult() *RemoteControllerTerminateMemberResult {
	return &RemoteControllerTerminateMemberResult{}
}

var RemoteControllerTerminateMemberResult_Success_DEFAULT bool

func (p *RemoteControllerTerminateMemberResult) GetSuccess() bool {
	if !p.IsSetSuccess() {
		return RemoteControllerTerminateMemberResult_Success_DEFAULT
	}
	return *p.Success
}
func (p *RemoteControllerTerminateMemberResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *RemoteControllerTerminateMemberResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.BOOL {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *RemoteControllerTerminateMemberResult) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(ctx); err != nil {
		return thrift.PrependError("error reading field 0: ", err)
	} else {
		p.Success = &v
	}
	return nil
}

func (p *RemoteControllerTerminateMemberResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "terminateMember_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *RemoteControllerTerminateMemberResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.BOOL, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := oprot.WriteBool(ctx, bool(*p.Success)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *RemoteControllerTerminateMemberResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("RemoteControllerTerminateMemberResult(%+v)", *p)
}

// Attributes:
//  - ClusterId
//  - MemberId
type RemoteControllerSuspendMemberArgs struct {
	ClusterId string `thrift:"clusterId,1" db:"clusterId" json:"clusterId"`
	MemberId  string `thrift:"memberId,2" db:"memberId" json:"memberId"`
}

func NewRemoteControllerSuspendMemberArgs() *RemoteControllerSuspendMemberArgs {
	return &RemoteControllerSuspendMemberArgs{}
}

func (p *RemoteControllerSuspendMemberArgs) GetClusterId() string {
	return p.ClusterId
}

func (p *RemoteControllerSuspendMemberArgs) GetMemberId() string {
	return p.MemberId
}
func (p *RemoteControllerSuspendMemberArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *RemoteControllerSuspendMemberArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.ClusterId = v
	}
	return nil
}

func (p *RemoteControllerSuspendMemberArgs) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.MemberId = v
	}
	return nil
}

func (p *RemoteControllerSuspendMemberArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "suspendMember_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *RemoteControllerSuspendMemberArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "clusterId", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:clusterId: ", p), err)
	}
	if err := oprot.WriteString(ctx, string(p.ClusterId)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.clusterId (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:clusterId: ", p), err)
	}
	return err
}

func (p *RemoteControllerSuspendMemberArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "memberId", thrift.STRING, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:memberId: ", p), err)
	}
	if err := oprot.WriteString(ctx, string(p.MemberId)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.memberId (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:memberId: ", p), err)
	}
	return err
}

func (p *RemoteControllerSuspendMemberArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("RemoteControllerSuspendMemberArgs(%+v)", *p)
}

// Attributes:
//  - Success
type RemoteControllerSuspendMemberResult struct {
	Success *bool `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewRemoteControllerSuspendMemberResult() *RemoteControllerSuspendMemberResult {
	return &RemoteControllerSuspendMemberResult{}
}

var RemoteControllerSuspendMemberResult_Success_DEFAULT bool

func (p *RemoteControllerSuspendMemberResult) GetSuccess() bool {
	if !p.IsSetSuccess() {
		return RemoteControllerSuspendMemberResult_Success_DEFAULT
	}
	return *p.Success
}
func (p *RemoteControllerSuspendMemberResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *RemoteControllerSuspendMemberResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.BOOL {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *RemoteControllerSuspendMemberResult) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(ctx); err != nil {
		return thrift.PrependError("error reading field 0: ", err)
	} else {
		p.Success = &v
	}
	return nil
}

func (p *RemoteControllerSuspendMemberResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "suspendMember_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *RemoteControllerSuspendMemberResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.BOOL, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := oprot.WriteBool(ctx, bool(*p.Success)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *RemoteControllerSuspendMemberResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("RemoteControllerSuspendMemberResult(%+v)", *p)
}

// Attributes:
//  - ClusterId
//  - MemberId
type RemoteControllerResumeMemberArgs struct {
	ClusterId string `thrift:"clusterId,1" db:"clusterId" json:"clusterId"`
	MemberId  string `thrift:"memberId,2" db:"memberId" json:"memberId"`
}

func NewRemoteControllerResumeMemberArgs() *RemoteControllerResumeMemberArgs {
	return &RemoteControllerResumeMemberArgs{}
}

func (p *RemoteControllerResumeMemberArgs) GetClusterId() string {
	return p.ClusterId
}

func (p *RemoteControllerResumeMemberArgs) GetMemberId() string {
	return p.MemberId
}
func (p *RemoteControllerResumeMemberArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *RemoteControllerResumeMemberArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.ClusterId = v
	}
	return nil
}

func (p *RemoteControllerResumeMemberArgs) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.MemberId = v
	}
	return nil
}

func (p *RemoteControllerResumeMemberArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "resumeMember_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *RemoteControllerResumeMemberArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "clusterId", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:clusterId: ", p), err)
	}
	if err := oprot.WriteString(ctx, string(p.ClusterId)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.clusterId (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:clusterId: ", p), err)
	}
	return err
}

func (p *RemoteControllerResumeMemberArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "memberId", thrift.STRING, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:memberId: ", p), err)
	}
	if err := oprot.WriteString(ctx, string(p.MemberId)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.memberId (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:memberId: ", p), err)
	}
	return err
}

func (p *RemoteControllerResumeMemberArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("RemoteControllerResumeMemberArgs(%+v)", *p)
}

// Attributes:
//  - Success
type RemoteControllerResumeMemberResult struct {
	Success *bool `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewRemoteControllerResumeMemberResult() *RemoteControllerResumeMemberResult {
	return &RemoteControllerResumeMemberResult{}
}

var RemoteControllerResumeMemberResult_Success_DEFAULT bool

func (p *RemoteControllerResumeMemberResult) GetSuccess() bool {
	if !p.IsSetSuccess() {
		return RemoteControllerResumeMemberResult_Success_DEFAULT
	}
	return *p.Success
}
func (p *RemoteControllerResumeMemberResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *RemoteControllerResumeMemberResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.BOOL {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *RemoteControllerResumeMemberResult) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(ctx); err != nil {
		return thrift.PrependError("error reading field 0: ", err)
	} else {
		p.Success = &v
	}
	return nil
}

func (p *RemoteControllerResumeMemberResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "resumeMember_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *RemoteControllerResumeMemberResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.BOOL, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := oprot.WriteBool(ctx, bool(*p.Success)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *RemoteControllerResumeMemberResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("RemoteControllerResumeMemberResult(%+v)", *p)
}

// Attributes:
//  - ClusterId
type RemoteControllerShutdownClusterArgs struct {
	ClusterId string `thrift:"clusterId,1" db:"clusterId" json:"clusterId"`
}

func NewRemoteControllerShutdownClusterArgs() *RemoteControllerShutdownClusterArgs {
	return &RemoteControllerShutdownClusterArgs{}
}

func (p *RemoteControllerShutdownClusterArgs) GetClusterId() string {
	return p.ClusterId
}
func (p *RemoteControllerShutdownClusterArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *RemoteControllerShutdownClusterArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.ClusterId = v
	}
	return nil
}

func (p *RemoteControllerShutdownClusterArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "shutdownCluster_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *RemoteControllerShutdownClusterArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "clusterId", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:clusterId: ", p), err)
	}
	if err := oprot.WriteString(ctx, string(p.ClusterId)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.clusterId (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:clusterId: ", p), err)
	}
	return err
}

func (p *RemoteControllerShutdownClusterArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("RemoteControllerShutdownClusterArgs(%+v)", *p)
}

// Attributes:
//  - Success
type RemoteControllerShutdownClusterResult struct {
	Success *bool `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewRemoteControllerShutdownClusterResult() *RemoteControllerShutdownClusterResult {
	return &RemoteControllerShutdownClusterResult{}
}

var RemoteControllerShutdownClusterResult_Success_DEFAULT bool

func (p *RemoteControllerShutdownClusterResult) GetSuccess() bool {
	if !p.IsSetSuccess() {
		return RemoteControllerShutdownClusterResult_Success_DEFAULT
	}
	return *p.Success
}
func (p *RemoteControllerShutdownClusterResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *RemoteControllerShutdownClusterResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.BOOL {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *RemoteControllerShutdownClusterResult) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(ctx); err != nil {
		return thrift.PrependError("error reading field 0: ", err)
	} else {
		p.Success = &v
	}
	return nil
}

func (p *RemoteControllerShutdownClusterResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "shutdownCluster_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *RemoteControllerShutdownClusterResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.BOOL, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := oprot.WriteBool(ctx, bool(*p.Success)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *RemoteControllerShutdownClusterResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("RemoteControllerShutdownClusterResult(%+v)", *p)
}

// Attributes:
//  - ClusterId
type RemoteControllerTerminateClusterArgs struct {
	ClusterId string `thrift:"clusterId,1" db:"clusterId" json:"clusterId"`
}

func NewRemoteControllerTerminateClusterArgs() *RemoteControllerTerminateClusterArgs {
	return &RemoteControllerTerminateClusterArgs{}
}

func (p *RemoteControllerTerminateClusterArgs) GetClusterId() string {
	return p.ClusterId
}
func (p *RemoteControllerTerminateClusterArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *RemoteControllerTerminateClusterArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.ClusterId = v
	}
	return nil
}

func (p *RemoteControllerTerminateClusterArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "terminateCluster_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *RemoteControllerTerminateClusterArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "clusterId", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:clusterId: ", p), err)
	}
	if err := oprot.WriteString(ctx, string(p.ClusterId)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.clusterId (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:clusterId: ", p), err)
	}
	return err
}

func (p *RemoteControllerTerminateClusterArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("RemoteControllerTerminateClusterArgs(%+v)", *p)
}

// Attributes:
//  - Success
type RemoteControllerTerminateClusterResult struct {
	Success *bool `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewRemoteControllerTerminateClusterResult() *RemoteControllerTerminateClusterResult {
	return &RemoteControllerTerminateClusterResult{}
}

var RemoteControllerTerminateClusterResult_Success_DEFAULT bool

func (p *RemoteControllerTerminateClusterResult) GetSuccess() bool {
	if !p.IsSetSuccess() {
		return RemoteControllerTerminateClusterResult_Success_DEFAULT
	}
	return *p.Success
}
func (p *RemoteControllerTerminateClusterResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *RemoteControllerTerminateClusterResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.BOOL {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *RemoteControllerTerminateClusterResult) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(ctx); err != nil {
		return thrift.PrependError("error reading field 0: ", err)
	} else {
		p.Success = &v
	}
	return nil
}

func (p *RemoteControllerTerminateClusterResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "terminateCluster_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *RemoteControllerTerminateClusterResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.BOOL, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := oprot.WriteBool(ctx, bool(*p.Success)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *RemoteControllerTerminateClusterResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("RemoteControllerTerminateClusterResult(%+v)", *p)
}

// Attributes:
//  - MemberId
type RemoteControllerSplitMemberFromClusterArgs struct {
	MemberId string `thrift:"memberId,1" db:"memberId" json:"memberId"`
}

func NewRemoteControllerSplitMemberFromClusterArgs() *RemoteControllerSplitMemberFromClusterArgs {
	return &RemoteControllerSplitMemberFromClusterArgs{}
}

func (p *RemoteControllerSplitMemberFromClusterArgs) GetMemberId() string {
	return p.MemberId
}
func (p *RemoteControllerSplitMemberFromClusterArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *RemoteControllerSplitMemberFromClusterArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.MemberId = v
	}
	return nil
}

func (p *RemoteControllerSplitMemberFromClusterArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "splitMemberFromCluster_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *RemoteControllerSplitMemberFromClusterArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "memberId", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:memberId: ", p), err)
	}
	if err := oprot.WriteString(ctx, string(p.MemberId)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.memberId (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:memberId: ", p), err)
	}
	return err
}

func (p *RemoteControllerSplitMemberFromClusterArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("RemoteControllerSplitMemberFromClusterArgs(%+v)", *p)
}

// Attributes:
//  - Success
type RemoteControllerSplitMemberFromClusterResult struct {
	Success *Cluster `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewRemoteControllerSplitMemberFromClusterResult() *RemoteControllerSplitMemberFromClusterResult {
	return &RemoteControllerSplitMemberFromClusterResult{}
}

var RemoteControllerSplitMemberFromClusterResult_Success_DEFAULT *Cluster

func (p *RemoteControllerSplitMemberFromClusterResult) GetSuccess() *Cluster {
	if !p.IsSetSuccess() {
		return RemoteControllerSplitMemberFromClusterResult_Success_DEFAULT
	}
	return p.Success
}
func (p *RemoteControllerSplitMemberFromClusterResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *RemoteControllerSplitMemberFromClusterResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *RemoteControllerSplitMemberFromClusterResult) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	p.Success = &Cluster{}
	if err := p.Success.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *RemoteControllerSplitMemberFromClusterResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "splitMemberFromCluster_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *RemoteControllerSplitMemberFromClusterResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *RemoteControllerSplitMemberFromClusterResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("RemoteControllerSplitMemberFromClusterResult(%+v)", *p)
}

// Attributes:
//  - ClusterId
//  - MemberId
type RemoteControllerMergeMemberToClusterArgs struct {
	ClusterId string `thrift:"clusterId,1" db:"clusterId" json:"clusterId"`
	MemberId  string `thrift:"memberId,2" db:"memberId" json:"memberId"`
}

func NewRemoteControllerMergeMemberToClusterArgs() *RemoteControllerMergeMemberToClusterArgs {
	return &RemoteControllerMergeMemberToClusterArgs{}
}

func (p *RemoteControllerMergeMemberToClusterArgs) GetClusterId() string {
	return p.ClusterId
}

func (p *RemoteControllerMergeMemberToClusterArgs) GetMemberId() string {
	return p.MemberId
}
func (p *RemoteControllerMergeMemberToClusterArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *RemoteControllerMergeMemberToClusterArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.ClusterId = v
	}
	return nil
}

func (p *RemoteControllerMergeMemberToClusterArgs) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.MemberId = v
	}
	return nil
}

func (p *RemoteControllerMergeMemberToClusterArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "mergeMemberToCluster_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *RemoteControllerMergeMemberToClusterArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "clusterId", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:clusterId: ", p), err)
	}
	if err := oprot.WriteString(ctx, string(p.ClusterId)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.clusterId (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:clusterId: ", p), err)
	}
	return err
}

func (p *RemoteControllerMergeMemberToClusterArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "memberId", thrift.STRING, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:memberId: ", p), err)
	}
	if err := oprot.WriteString(ctx, string(p.MemberId)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.memberId (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:memberId: ", p), err)
	}
	return err
}

func (p *RemoteControllerMergeMemberToClusterArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("RemoteControllerMergeMemberToClusterArgs(%+v)", *p)
}

// Attributes:
//  - Success
type RemoteControllerMergeMemberToClusterResult struct {
	Success *Cluster `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewRemoteControllerMergeMemberToClusterResult() *RemoteControllerMergeMemberToClusterResult {
	return &RemoteControllerMergeMemberToClusterResult{}
}

var RemoteControllerMergeMemberToClusterResult_Success_DEFAULT *Cluster

func (p *RemoteControllerMergeMemberToClusterResult) GetSuccess() *Cluster {
	if !p.IsSetSuccess() {
		return RemoteControllerMergeMemberToClusterResult_Success_DEFAULT
	}
	return p.Success
}
func (p *RemoteControllerMergeMemberToClusterResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *RemoteControllerMergeMemberToClusterResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *RemoteControllerMergeMemberToClusterResult) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	p.Success = &Cluster{}
	if err := p.Success.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *RemoteControllerMergeMemberToClusterResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "mergeMemberToCluster_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *RemoteControllerMergeMemberToClusterResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *RemoteControllerMergeMemberToClusterResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("RemoteControllerMergeMemberToClusterResult(%+v)", *p)
}

// Attributes:
//  - ClusterId
//  - Script
//  - Lang
type RemoteControllerExecuteOnControllerArgs struct {
	ClusterId string `thrift:"clusterId,1" db:"clusterId" json:"clusterId"`
	Script    string `thrift:"script,2" db:"script" json:"script"`
	Lang      Lang   `thrift:"lang,3" db:"lang" json:"lang"`
}

func NewRemoteControllerExecuteOnControllerArgs() *RemoteControllerExecuteOnControllerArgs {
	return &RemoteControllerExecuteOnControllerArgs{}
}

func (p *RemoteControllerExecuteOnControllerArgs) GetClusterId() string {
	return p.ClusterId
}

func (p *RemoteControllerExecuteOnControllerArgs) GetScript() string {
	return p.Script
}

func (p *RemoteControllerExecuteOnControllerArgs) GetLang() Lang {
	return p.Lang
}
func (p *RemoteControllerExecuteOnControllerArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 3:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField3(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *RemoteControllerExecuteOnControllerArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.ClusterId = v
	}
	return nil
}

func (p *RemoteControllerExecuteOnControllerArgs) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.Script = v
	}
	return nil
}

func (p *RemoteControllerExecuteOnControllerArgs) ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		temp := Lang(v)
		p.Lang = temp
	}
	return nil
}

func (p *RemoteControllerExecuteOnControllerArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "executeOnController_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField3(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *RemoteControllerExecuteOnControllerArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "clusterId", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:clusterId: ", p), err)
	}
	if err := oprot.WriteString(ctx, string(p.ClusterId)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.clusterId (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:clusterId: ", p), err)
	}
	return err
}

func (p *RemoteControllerExecuteOnControllerArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "script", thrift.STRING, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:script: ", p), err)
	}
	if err := oprot.WriteString(ctx, string(p.Script)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.script (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:script: ", p), err)
	}
	return err
}

func (p *RemoteControllerExecuteOnControllerArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "lang", thrift.I32, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:lang: ", p), err)
	}
	if err := oprot.WriteI32(ctx, int32(p.Lang)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.lang (3) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:lang: ", p), err)
	}
	return err
}

func (p *RemoteControllerExecuteOnControllerArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("RemoteControllerExecuteOnControllerArgs(%+v)", *p)
}

// Attributes:
//  - Success
type RemoteControllerExecuteOnControllerResult struct {
	Success *Response `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewRemoteControllerExecuteOnControllerResult() *RemoteControllerExecuteOnControllerResult {
	return &RemoteControllerExecuteOnControllerResult{}
}

var RemoteControllerExecuteOnControllerResult_Success_DEFAULT *Response

func (p *RemoteControllerExecuteOnControllerResult) GetSuccess() *Response {
	if !p.IsSetSuccess() {
		return RemoteControllerExecuteOnControllerResult_Success_DEFAULT
	}
	return p.Success
}
func (p *RemoteControllerExecuteOnControllerResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *RemoteControllerExecuteOnControllerResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *RemoteControllerExecuteOnControllerResult) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	p.Success = &Response{}
	if err := p.Success.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *RemoteControllerExecuteOnControllerResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "executeOnController_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *RemoteControllerExecuteOnControllerResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *RemoteControllerExecuteOnControllerResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("RemoteControllerExecuteOnControllerResult(%+v)", *p)
}
