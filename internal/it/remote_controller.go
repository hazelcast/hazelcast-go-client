/*
 * Copyright (c) 2008-2022, Hazelcast, Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License")
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Code generated by Thrift Compiler (0.15.0). DO NOT EDIT.

package it

import (
	"bytes"
	"context"
	"database/sql/driver"
	"errors"
	"fmt"
	"time"
	thrift "github.com/apache/thrift/lib/go/thrift"
)

// (needed to ensure safety because of naive import list construction.)
var _ = thrift.ZERO
var _ = fmt.Printf
var _ = context.Background
var _ = time.Now
var _ = bytes.Equal

type Lang int64
const (
  Lang_JAVASCRIPT Lang = 1
  Lang_GROOVY Lang = 2
  Lang_PYTHON Lang = 3
  Lang_RUBY Lang = 4
)

func (p Lang) String() string {
  switch p {
  case Lang_JAVASCRIPT: return "JAVASCRIPT"
  case Lang_GROOVY: return "GROOVY"
  case Lang_PYTHON: return "PYTHON"
  case Lang_RUBY: return "RUBY"
  }
  return "<UNSET>"
}

func LangFromString(s string) (Lang, error) {
  switch s {
  case "JAVASCRIPT": return Lang_JAVASCRIPT, nil 
  case "GROOVY": return Lang_GROOVY, nil 
  case "PYTHON": return Lang_PYTHON, nil 
  case "RUBY": return Lang_RUBY, nil 
  }
  return Lang(0), fmt.Errorf("not a valid Lang string")
}


func LangPtr(v Lang) *Lang { return &v }

func (p Lang) MarshalText() ([]byte, error) {
return []byte(p.String()), nil
}

func (p *Lang) UnmarshalText(text []byte) error {
q, err := LangFromString(string(text))
if (err != nil) {
return err
}
*p = q
return nil
}

func (p *Lang) Scan(value interface{}) error {
v, ok := value.(int64)
if !ok {
return errors.New("Scan value is not int64")
}
*p = Lang(v)
return nil
}

func (p * Lang) Value() (driver.Value, error) {
  if p == nil {
    return nil, nil
  }
return int64(*p), nil
}
// Attributes:
//  - ID
type Cluster struct {
  ID string `thrift:"id,1" db:"id" json:"id"`
}

func NewCluster() *Cluster {
  return &Cluster{}
}


func (p *Cluster) GetID() string {
  return p.ID
}
func (p *Cluster) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *Cluster)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.ID = v
}
  return nil
}

func (p *Cluster) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "Cluster"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *Cluster) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "id", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:id: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.ID)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.id (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:id: ", p), err) }
  return err
}

func (p *Cluster) Equals(other *Cluster) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.ID != other.ID { return false }
  return true
}

func (p *Cluster) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("Cluster(%+v)", *p)
}

// Attributes:
//  - ID
//  - Name
//  - NameForConnect
//  - HazelcastVersion
//  - IsTlsEnabled
//  - State
//  - Token
//  - CertificatePath
//  - TlsPassword
type CloudCluster struct {
  ID string `thrift:"id,1" db:"id" json:"id"`
  Name string `thrift:"name,2" db:"name" json:"name"`
  NameForConnect string `thrift:"nameForConnect,3" db:"nameForConnect" json:"nameForConnect"`
  HazelcastVersion string `thrift:"hazelcastVersion,4" db:"hazelcastVersion" json:"hazelcastVersion"`
  IsTlsEnabled bool `thrift:"isTlsEnabled,5" db:"isTlsEnabled" json:"isTlsEnabled"`
  State string `thrift:"state,6" db:"state" json:"state"`
  Token string `thrift:"token,7" db:"token" json:"token"`
  CertificatePath string `thrift:"certificatePath,8" db:"certificatePath" json:"certificatePath"`
  TlsPassword string `thrift:"tlsPassword,9" db:"tlsPassword" json:"tlsPassword"`
}

func NewCloudCluster() *CloudCluster {
  return &CloudCluster{}
}


func (p *CloudCluster) GetID() string {
  return p.ID
}

func (p *CloudCluster) GetName() string {
  return p.Name
}

func (p *CloudCluster) GetNameForConnect() string {
  return p.NameForConnect
}

func (p *CloudCluster) GetHazelcastVersion() string {
  return p.HazelcastVersion
}

func (p *CloudCluster) GetIsTlsEnabled() bool {
  return p.IsTlsEnabled
}

func (p *CloudCluster) GetState() string {
  return p.State
}

func (p *CloudCluster) GetToken() string {
  return p.Token
}

func (p *CloudCluster) GetCertificatePath() string {
  return p.CertificatePath
}

func (p *CloudCluster) GetTlsPassword() string {
  return p.TlsPassword
}
func (p *CloudCluster) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 6:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField6(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 7:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField7(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 8:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField8(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 9:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField9(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *CloudCluster)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.ID = v
}
  return nil
}

func (p *CloudCluster)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Name = v
}
  return nil
}

func (p *CloudCluster)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.NameForConnect = v
}
  return nil
}

func (p *CloudCluster)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.HazelcastVersion = v
}
  return nil
}

func (p *CloudCluster)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 5: ", err)
} else {
  p.IsTlsEnabled = v
}
  return nil
}

func (p *CloudCluster)  ReadField6(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 6: ", err)
} else {
  p.State = v
}
  return nil
}

func (p *CloudCluster)  ReadField7(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 7: ", err)
} else {
  p.Token = v
}
  return nil
}

func (p *CloudCluster)  ReadField8(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 8: ", err)
} else {
  p.CertificatePath = v
}
  return nil
}

func (p *CloudCluster)  ReadField9(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 9: ", err)
} else {
  p.TlsPassword = v
}
  return nil
}

func (p *CloudCluster) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "CloudCluster"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
    if err := p.writeField6(ctx, oprot); err != nil { return err }
    if err := p.writeField7(ctx, oprot); err != nil { return err }
    if err := p.writeField8(ctx, oprot); err != nil { return err }
    if err := p.writeField9(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CloudCluster) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "id", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:id: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.ID)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.id (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:id: ", p), err) }
  return err
}

func (p *CloudCluster) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "name", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:name: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Name)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.name (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:name: ", p), err) }
  return err
}

func (p *CloudCluster) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "nameForConnect", thrift.STRING, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:nameForConnect: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.NameForConnect)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.nameForConnect (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:nameForConnect: ", p), err) }
  return err
}

func (p *CloudCluster) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "hazelcastVersion", thrift.STRING, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:hazelcastVersion: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.HazelcastVersion)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.hazelcastVersion (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:hazelcastVersion: ", p), err) }
  return err
}

func (p *CloudCluster) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "isTlsEnabled", thrift.BOOL, 5); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:isTlsEnabled: ", p), err) }
  if err := oprot.WriteBool(ctx, bool(p.IsTlsEnabled)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.isTlsEnabled (5) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 5:isTlsEnabled: ", p), err) }
  return err
}

func (p *CloudCluster) writeField6(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "state", thrift.STRING, 6); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:state: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.State)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.state (6) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 6:state: ", p), err) }
  return err
}

func (p *CloudCluster) writeField7(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "token", thrift.STRING, 7); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 7:token: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Token)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.token (7) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 7:token: ", p), err) }
  return err
}

func (p *CloudCluster) writeField8(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "certificatePath", thrift.STRING, 8); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 8:certificatePath: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.CertificatePath)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.certificatePath (8) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 8:certificatePath: ", p), err) }
  return err
}

func (p *CloudCluster) writeField9(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "tlsPassword", thrift.STRING, 9); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 9:tlsPassword: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.TlsPassword)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.tlsPassword (9) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 9:tlsPassword: ", p), err) }
  return err
}

func (p *CloudCluster) Equals(other *CloudCluster) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.ID != other.ID { return false }
  if p.Name != other.Name { return false }
  if p.NameForConnect != other.NameForConnect { return false }
  if p.HazelcastVersion != other.HazelcastVersion { return false }
  if p.IsTlsEnabled != other.IsTlsEnabled { return false }
  if p.State != other.State { return false }
  if p.Token != other.Token { return false }
  if p.CertificatePath != other.CertificatePath { return false }
  if p.TlsPassword != other.TlsPassword { return false }
  return true
}

func (p *CloudCluster) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CloudCluster(%+v)", *p)
}

// Attributes:
//  - UUID
//  - Host
//  - Port
type Member struct {
  UUID string `thrift:"uuid,1" db:"uuid" json:"uuid"`
  Host string `thrift:"host,2" db:"host" json:"host"`
  Port int32 `thrift:"port,3" db:"port" json:"port"`
}

func NewMember() *Member {
  return &Member{}
}


func (p *Member) GetUUID() string {
  return p.UUID
}

func (p *Member) GetHost() string {
  return p.Host
}

func (p *Member) GetPort() int32 {
  return p.Port
}
func (p *Member) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *Member)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.UUID = v
}
  return nil
}

func (p *Member)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Host = v
}
  return nil
}

func (p *Member)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Port = v
}
  return nil
}

func (p *Member) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "Member"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *Member) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "uuid", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:uuid: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.UUID)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.uuid (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:uuid: ", p), err) }
  return err
}

func (p *Member) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "host", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:host: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Host)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.host (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:host: ", p), err) }
  return err
}

func (p *Member) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "port", thrift.I32, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:port: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Port)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.port (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:port: ", p), err) }
  return err
}

func (p *Member) Equals(other *Member) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.UUID != other.UUID { return false }
  if p.Host != other.Host { return false }
  if p.Port != other.Port { return false }
  return true
}

func (p *Member) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("Member(%+v)", *p)
}

// Attributes:
//  - Success
//  - Message
//  - Result_
type Response struct {
  Success bool `thrift:"success,1" db:"success" json:"success"`
  Message string `thrift:"message,2" db:"message" json:"message"`
  Result_ []byte `thrift:"result,3" db:"result" json:"result"`
}

func NewResponse() *Response {
  return &Response{}
}


func (p *Response) GetSuccess() bool {
  return p.Success
}

func (p *Response) GetMessage() string {
  return p.Message
}

func (p *Response) GetResult_() []byte {
  return p.Result_
}
func (p *Response) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *Response)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Success = v
}
  return nil
}

func (p *Response)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Message = v
}
  return nil
}

func (p *Response)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Result_ = v
}
  return nil
}

func (p *Response) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "Response"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *Response) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "success", thrift.BOOL, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:success: ", p), err) }
  if err := oprot.WriteBool(ctx, bool(p.Success)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.success (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:success: ", p), err) }
  return err
}

func (p *Response) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "message", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:message: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Message)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.message (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:message: ", p), err) }
  return err
}

func (p *Response) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "result", thrift.STRING, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:result: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Result_); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.result (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:result: ", p), err) }
  return err
}

func (p *Response) Equals(other *Response) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.Success != other.Success { return false }
  if p.Message != other.Message { return false }
  if bytes.Compare(p.Result_, other.Result_) != 0 { return false }
  return true
}

func (p *Response) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("Response(%+v)", *p)
}

// Attributes:
//  - Message
type ServerException struct {
  Message string `thrift:"message,1" db:"message" json:"message"`
}

func NewServerException() *ServerException {
  return &ServerException{}
}


func (p *ServerException) GetMessage() string {
  return p.Message
}
func (p *ServerException) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ServerException)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Message = v
}
  return nil
}

func (p *ServerException) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "ServerException"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ServerException) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "message", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:message: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Message)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.message (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:message: ", p), err) }
  return err
}

func (p *ServerException) Equals(other *ServerException) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.Message != other.Message { return false }
  return true
}

func (p *ServerException) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ServerException(%+v)", *p)
}

func (p *ServerException) Error() string {
  return p.String()
}

func (ServerException) TExceptionType() thrift.TExceptionType {
  return thrift.TExceptionTypeCompiled
}

var _ thrift.TException = (*ServerException)(nil)

// Attributes:
//  - Message
type CloudException struct {
  Message string `thrift:"message,1" db:"message" json:"message"`
}

func NewCloudException() *CloudException {
  return &CloudException{}
}


func (p *CloudException) GetMessage() string {
  return p.Message
}
func (p *CloudException) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *CloudException)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Message = v
}
  return nil
}

func (p *CloudException) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "CloudException"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CloudException) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "message", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:message: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Message)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.message (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:message: ", p), err) }
  return err
}

func (p *CloudException) Equals(other *CloudException) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.Message != other.Message { return false }
  return true
}

func (p *CloudException) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CloudException(%+v)", *p)
}

func (p *CloudException) Error() string {
  return p.String()
}

func (CloudException) TExceptionType() thrift.TExceptionType {
  return thrift.TExceptionTypeCompiled
}

var _ thrift.TException = (*CloudException)(nil)

type RemoteController interface {
  Ping(ctx context.Context) (_r bool, _err error)
  Clean(ctx context.Context) (_r bool, _err error)
  Exit(ctx context.Context) (_r bool, _err error)
  // Parameters:
  //  - HzVersion
  //  - Xmlconfig
  CreateCluster(ctx context.Context, hzVersion string, xmlconfig string) (_r *Cluster, _err error)
  // Parameters:
  //  - HzVersion
  //  - Xmlconfig
  CreateClusterKeepClusterName(ctx context.Context, hzVersion string, xmlconfig string) (_r *Cluster, _err error)
  // Parameters:
  //  - ClusterId
  StartMember(ctx context.Context, clusterId string) (_r *Member, _err error)
  // Parameters:
  //  - ClusterId
  //  - MemberId
  ShutdownMember(ctx context.Context, clusterId string, memberId string) (_r bool, _err error)
  // Parameters:
  //  - ClusterId
  //  - MemberId
  TerminateMember(ctx context.Context, clusterId string, memberId string) (_r bool, _err error)
  // Parameters:
  //  - ClusterId
  //  - MemberId
  SuspendMember(ctx context.Context, clusterId string, memberId string) (_r bool, _err error)
  // Parameters:
  //  - ClusterId
  //  - MemberId
  ResumeMember(ctx context.Context, clusterId string, memberId string) (_r bool, _err error)
  // Parameters:
  //  - ClusterId
  ShutdownCluster(ctx context.Context, clusterId string) (_r bool, _err error)
  // Parameters:
  //  - ClusterId
  TerminateCluster(ctx context.Context, clusterId string) (_r bool, _err error)
  // Parameters:
  //  - MemberId
  SplitMemberFromCluster(ctx context.Context, memberId string) (_r *Cluster, _err error)
  // Parameters:
  //  - ClusterId
  //  - MemberId
  MergeMemberToCluster(ctx context.Context, clusterId string, memberId string) (_r *Cluster, _err error)
  // Reads the environment variables and calls loginToHazelcastCloud() method with these variables.
  // @throws CloudException
  LoginToHazelcastCloudUsingEnvironment(ctx context.Context) (_err error)
  // Logins the hazelcast cloud, sets the bearer token, uri and baseUrl to HazelcastCloudManager then it will be ready to use cloud API
  // @throws CloudException
  // 
  // @param baseUrl -> Base url of the cloud environment. i.e. https://uat.hazelcast.cloud
  // @param apiKey -> Api key of the hazelcast cloud
  // @param apiSecret -> Api secret of the hazelcast cloud
  // 
  // Parameters:
  //  - BaseUrl
  //  - ApiKey
  //  - ApiSecret
  LoginToHazelcastCloud(ctx context.Context, baseUrl string, apiKey string, apiSecret string) (_err error)
  // Creates a standard cluster
  // @return CloudCluster
  // @throws CloudException
  // 
  // @param hazelcastVersion
  // @param isTlsEnabled -> True if ssl enabled cluster is requested, otherwise false.
  // 
  // Parameters:
  //  - HazelcastVersion
  //  - IsTlsEnabled
  CreateHazelcastCloudStandardCluster(ctx context.Context, hazelcastVersion string, isTlsEnabled bool) (_r *CloudCluster, _err error)
  // Setting member count of the cluster
  // @throws CloudException
  // 
  // @param cloudClusterId
  // @param totalMemberCount -> Total member count of the cluster
  // 
  // Parameters:
  //  - CloudClusterId
  //  - TotalMemberCount
  SetHazelcastCloudClusterMemberCount(ctx context.Context, cloudClusterId string, totalMemberCount int32) (_err error)
  // Get information of the given cluster
  // @return CloudCluster
  // @throws CloudException
  // 
  // @param cloudClusterId
  // 
  // Parameters:
  //  - CloudClusterId
  GetHazelcastCloudCluster(ctx context.Context, cloudClusterId string) (_r *CloudCluster, _err error)
  // Stops the given cluster
  // @return CloudCluster
  // @throws CloudException
  // 
  // @param cloudClusterId
  // 
  // Parameters:
  //  - CloudClusterId
  StopHazelcastCloudCluster(ctx context.Context, cloudClusterId string) (_r *CloudCluster, _err error)
  // Resumes the given cluster
  // @return CloudCluster
  // @throws CloudException
  // 
  // @param cloudClusterId
  // 
  // Parameters:
  //  - CloudClusterId
  ResumeHazelcastCloudCluster(ctx context.Context, cloudClusterId string) (_r *CloudCluster, _err error)
  // Deletes the given cluster
  // @return boolean
  // @throws CloudException
  // 
  // @param cloudClusterId
  // 
  // Parameters:
  //  - CloudClusterId
  DeleteHazelcastCloudCluster(ctx context.Context, cloudClusterId string) (_err error)
  // Parameters:
  //  - ClusterId
  //  - Script
  //  - Lang
  ExecuteOnController(ctx context.Context, clusterId string, script string, lang Lang) (_r *Response, _err error)
}

type RemoteControllerClient struct {
  c thrift.TClient
  meta thrift.ResponseMeta
}

func NewRemoteControllerClientFactory(t thrift.TTransport, f thrift.TProtocolFactory) *RemoteControllerClient {
  return &RemoteControllerClient{
    c: thrift.NewTStandardClient(f.GetProtocol(t), f.GetProtocol(t)),
  }
}

func NewRemoteControllerClientProtocol(t thrift.TTransport, iprot thrift.TProtocol, oprot thrift.TProtocol) *RemoteControllerClient {
  return &RemoteControllerClient{
    c: thrift.NewTStandardClient(iprot, oprot),
  }
}

func NewRemoteControllerClient(c thrift.TClient) *RemoteControllerClient {
  return &RemoteControllerClient{
    c: c,
  }
}

func (p *RemoteControllerClient) Client_() thrift.TClient {
  return p.c
}

func (p *RemoteControllerClient) LastResponseMeta_() thrift.ResponseMeta {
  return p.meta
}

func (p *RemoteControllerClient) SetLastResponseMeta_(meta thrift.ResponseMeta) {
  p.meta = meta
}

func (p *RemoteControllerClient) Ping(ctx context.Context) (_r bool, _err error) {
  var _args0 RemoteControllerPingArgs
  var _result2 RemoteControllerPingResult
  var _meta1 thrift.ResponseMeta
  _meta1, _err = p.Client_().Call(ctx, "ping", &_args0, &_result2)
  p.SetLastResponseMeta_(_meta1)
  if _err != nil {
    return
  }
  return _result2.GetSuccess(), nil
}

func (p *RemoteControllerClient) Clean(ctx context.Context) (_r bool, _err error) {
  var _args3 RemoteControllerCleanArgs
  var _result5 RemoteControllerCleanResult
  var _meta4 thrift.ResponseMeta
  _meta4, _err = p.Client_().Call(ctx, "clean", &_args3, &_result5)
  p.SetLastResponseMeta_(_meta4)
  if _err != nil {
    return
  }
  return _result5.GetSuccess(), nil
}

func (p *RemoteControllerClient) Exit(ctx context.Context) (_r bool, _err error) {
  var _args6 RemoteControllerExitArgs
  var _result8 RemoteControllerExitResult
  var _meta7 thrift.ResponseMeta
  _meta7, _err = p.Client_().Call(ctx, "exit", &_args6, &_result8)
  p.SetLastResponseMeta_(_meta7)
  if _err != nil {
    return
  }
  return _result8.GetSuccess(), nil
}

// Parameters:
//  - HzVersion
//  - Xmlconfig
func (p *RemoteControllerClient) CreateCluster(ctx context.Context, hzVersion string, xmlconfig string) (_r *Cluster, _err error) {
  var _args9 RemoteControllerCreateClusterArgs
  _args9.HzVersion = hzVersion
  _args9.Xmlconfig = xmlconfig
  var _result11 RemoteControllerCreateClusterResult
  var _meta10 thrift.ResponseMeta
  _meta10, _err = p.Client_().Call(ctx, "createCluster", &_args9, &_result11)
  p.SetLastResponseMeta_(_meta10)
  if _err != nil {
    return
  }
  switch {
  case _result11.ServerException!= nil:
    return _r, _result11.ServerException
  }

  if _ret12 := _result11.GetSuccess(); _ret12 != nil {
    return _ret12, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "createCluster failed: unknown result")
}

// Parameters:
//  - HzVersion
//  - Xmlconfig
func (p *RemoteControllerClient) CreateClusterKeepClusterName(ctx context.Context, hzVersion string, xmlconfig string) (_r *Cluster, _err error) {
  var _args13 RemoteControllerCreateClusterKeepClusterNameArgs
  _args13.HzVersion = hzVersion
  _args13.Xmlconfig = xmlconfig
  var _result15 RemoteControllerCreateClusterKeepClusterNameResult
  var _meta14 thrift.ResponseMeta
  _meta14, _err = p.Client_().Call(ctx, "createClusterKeepClusterName", &_args13, &_result15)
  p.SetLastResponseMeta_(_meta14)
  if _err != nil {
    return
  }
  switch {
  case _result15.ServerException!= nil:
    return _r, _result15.ServerException
  }

  if _ret16 := _result15.GetSuccess(); _ret16 != nil {
    return _ret16, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "createClusterKeepClusterName failed: unknown result")
}

// Parameters:
//  - ClusterId
func (p *RemoteControllerClient) StartMember(ctx context.Context, clusterId string) (_r *Member, _err error) {
  var _args17 RemoteControllerStartMemberArgs
  _args17.ClusterId = clusterId
  var _result19 RemoteControllerStartMemberResult
  var _meta18 thrift.ResponseMeta
  _meta18, _err = p.Client_().Call(ctx, "startMember", &_args17, &_result19)
  p.SetLastResponseMeta_(_meta18)
  if _err != nil {
    return
  }
  switch {
  case _result19.ServerException!= nil:
    return _r, _result19.ServerException
  }

  if _ret20 := _result19.GetSuccess(); _ret20 != nil {
    return _ret20, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "startMember failed: unknown result")
}

// Parameters:
//  - ClusterId
//  - MemberId
func (p *RemoteControllerClient) ShutdownMember(ctx context.Context, clusterId string, memberId string) (_r bool, _err error) {
  var _args21 RemoteControllerShutdownMemberArgs
  _args21.ClusterId = clusterId
  _args21.MemberId = memberId
  var _result23 RemoteControllerShutdownMemberResult
  var _meta22 thrift.ResponseMeta
  _meta22, _err = p.Client_().Call(ctx, "shutdownMember", &_args21, &_result23)
  p.SetLastResponseMeta_(_meta22)
  if _err != nil {
    return
  }
  return _result23.GetSuccess(), nil
}

// Parameters:
//  - ClusterId
//  - MemberId
func (p *RemoteControllerClient) TerminateMember(ctx context.Context, clusterId string, memberId string) (_r bool, _err error) {
  var _args24 RemoteControllerTerminateMemberArgs
  _args24.ClusterId = clusterId
  _args24.MemberId = memberId
  var _result26 RemoteControllerTerminateMemberResult
  var _meta25 thrift.ResponseMeta
  _meta25, _err = p.Client_().Call(ctx, "terminateMember", &_args24, &_result26)
  p.SetLastResponseMeta_(_meta25)
  if _err != nil {
    return
  }
  return _result26.GetSuccess(), nil
}

// Parameters:
//  - ClusterId
//  - MemberId
func (p *RemoteControllerClient) SuspendMember(ctx context.Context, clusterId string, memberId string) (_r bool, _err error) {
  var _args27 RemoteControllerSuspendMemberArgs
  _args27.ClusterId = clusterId
  _args27.MemberId = memberId
  var _result29 RemoteControllerSuspendMemberResult
  var _meta28 thrift.ResponseMeta
  _meta28, _err = p.Client_().Call(ctx, "suspendMember", &_args27, &_result29)
  p.SetLastResponseMeta_(_meta28)
  if _err != nil {
    return
  }
  return _result29.GetSuccess(), nil
}

// Parameters:
//  - ClusterId
//  - MemberId
func (p *RemoteControllerClient) ResumeMember(ctx context.Context, clusterId string, memberId string) (_r bool, _err error) {
  var _args30 RemoteControllerResumeMemberArgs
  _args30.ClusterId = clusterId
  _args30.MemberId = memberId
  var _result32 RemoteControllerResumeMemberResult
  var _meta31 thrift.ResponseMeta
  _meta31, _err = p.Client_().Call(ctx, "resumeMember", &_args30, &_result32)
  p.SetLastResponseMeta_(_meta31)
  if _err != nil {
    return
  }
  return _result32.GetSuccess(), nil
}

// Parameters:
//  - ClusterId
func (p *RemoteControllerClient) ShutdownCluster(ctx context.Context, clusterId string) (_r bool, _err error) {
  var _args33 RemoteControllerShutdownClusterArgs
  _args33.ClusterId = clusterId
  var _result35 RemoteControllerShutdownClusterResult
  var _meta34 thrift.ResponseMeta
  _meta34, _err = p.Client_().Call(ctx, "shutdownCluster", &_args33, &_result35)
  p.SetLastResponseMeta_(_meta34)
  if _err != nil {
    return
  }
  return _result35.GetSuccess(), nil
}

// Parameters:
//  - ClusterId
func (p *RemoteControllerClient) TerminateCluster(ctx context.Context, clusterId string) (_r bool, _err error) {
  var _args36 RemoteControllerTerminateClusterArgs
  _args36.ClusterId = clusterId
  var _result38 RemoteControllerTerminateClusterResult
  var _meta37 thrift.ResponseMeta
  _meta37, _err = p.Client_().Call(ctx, "terminateCluster", &_args36, &_result38)
  p.SetLastResponseMeta_(_meta37)
  if _err != nil {
    return
  }
  return _result38.GetSuccess(), nil
}

// Parameters:
//  - MemberId
func (p *RemoteControllerClient) SplitMemberFromCluster(ctx context.Context, memberId string) (_r *Cluster, _err error) {
  var _args39 RemoteControllerSplitMemberFromClusterArgs
  _args39.MemberId = memberId
  var _result41 RemoteControllerSplitMemberFromClusterResult
  var _meta40 thrift.ResponseMeta
  _meta40, _err = p.Client_().Call(ctx, "splitMemberFromCluster", &_args39, &_result41)
  p.SetLastResponseMeta_(_meta40)
  if _err != nil {
    return
  }
  if _ret42 := _result41.GetSuccess(); _ret42 != nil {
    return _ret42, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "splitMemberFromCluster failed: unknown result")
}

// Parameters:
//  - ClusterId
//  - MemberId
func (p *RemoteControllerClient) MergeMemberToCluster(ctx context.Context, clusterId string, memberId string) (_r *Cluster, _err error) {
  var _args43 RemoteControllerMergeMemberToClusterArgs
  _args43.ClusterId = clusterId
  _args43.MemberId = memberId
  var _result45 RemoteControllerMergeMemberToClusterResult
  var _meta44 thrift.ResponseMeta
  _meta44, _err = p.Client_().Call(ctx, "mergeMemberToCluster", &_args43, &_result45)
  p.SetLastResponseMeta_(_meta44)
  if _err != nil {
    return
  }
  if _ret46 := _result45.GetSuccess(); _ret46 != nil {
    return _ret46, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "mergeMemberToCluster failed: unknown result")
}

// Reads the environment variables and calls loginToHazelcastCloud() method with these variables.
// @throws CloudException
func (p *RemoteControllerClient) LoginToHazelcastCloudUsingEnvironment(ctx context.Context) (_err error) {
  var _args47 RemoteControllerLoginToHazelcastCloudUsingEnvironmentArgs
  var _result49 RemoteControllerLoginToHazelcastCloudUsingEnvironmentResult
  var _meta48 thrift.ResponseMeta
  _meta48, _err = p.Client_().Call(ctx, "loginToHazelcastCloudUsingEnvironment", &_args47, &_result49)
  p.SetLastResponseMeta_(_meta48)
  if _err != nil {
    return
  }
  switch {
  case _result49.CloudException!= nil:
    return _result49.CloudException
  }

  return nil
}

// Logins the hazelcast cloud, sets the bearer token, uri and baseUrl to HazelcastCloudManager then it will be ready to use cloud API
// @throws CloudException
// 
// @param baseUrl -> Base url of the cloud environment. i.e. https://uat.hazelcast.cloud
// @param apiKey -> Api key of the hazelcast cloud
// @param apiSecret -> Api secret of the hazelcast cloud
// 
// Parameters:
//  - BaseUrl
//  - ApiKey
//  - ApiSecret
func (p *RemoteControllerClient) LoginToHazelcastCloud(ctx context.Context, baseUrl string, apiKey string, apiSecret string) (_err error) {
  var _args50 RemoteControllerLoginToHazelcastCloudArgs
  _args50.BaseUrl = baseUrl
  _args50.ApiKey = apiKey
  _args50.ApiSecret = apiSecret
  var _result52 RemoteControllerLoginToHazelcastCloudResult
  var _meta51 thrift.ResponseMeta
  _meta51, _err = p.Client_().Call(ctx, "loginToHazelcastCloud", &_args50, &_result52)
  p.SetLastResponseMeta_(_meta51)
  if _err != nil {
    return
  }
  switch {
  case _result52.CloudException!= nil:
    return _result52.CloudException
  }

  return nil
}

// Creates a standard cluster
// @return CloudCluster
// @throws CloudException
// 
// @param hazelcastVersion
// @param isTlsEnabled -> True if ssl enabled cluster is requested, otherwise false.
// 
// Parameters:
//  - HazelcastVersion
//  - IsTlsEnabled
func (p *RemoteControllerClient) CreateHazelcastCloudStandardCluster(ctx context.Context, hazelcastVersion string, isTlsEnabled bool) (_r *CloudCluster, _err error) {
  var _args53 RemoteControllerCreateHazelcastCloudStandardClusterArgs
  _args53.HazelcastVersion = hazelcastVersion
  _args53.IsTlsEnabled = isTlsEnabled
  var _result55 RemoteControllerCreateHazelcastCloudStandardClusterResult
  var _meta54 thrift.ResponseMeta
  _meta54, _err = p.Client_().Call(ctx, "createHazelcastCloudStandardCluster", &_args53, &_result55)
  p.SetLastResponseMeta_(_meta54)
  if _err != nil {
    return
  }
  switch {
  case _result55.CloudException!= nil:
    return _r, _result55.CloudException
  }

  if _ret56 := _result55.GetSuccess(); _ret56 != nil {
    return _ret56, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "createHazelcastCloudStandardCluster failed: unknown result")
}

// Setting member count of the cluster
// @throws CloudException
// 
// @param cloudClusterId
// @param totalMemberCount -> Total member count of the cluster
// 
// Parameters:
//  - CloudClusterId
//  - TotalMemberCount
func (p *RemoteControllerClient) SetHazelcastCloudClusterMemberCount(ctx context.Context, cloudClusterId string, totalMemberCount int32) (_err error) {
  var _args57 RemoteControllerSetHazelcastCloudClusterMemberCountArgs
  _args57.CloudClusterId = cloudClusterId
  _args57.TotalMemberCount = totalMemberCount
  var _result59 RemoteControllerSetHazelcastCloudClusterMemberCountResult
  var _meta58 thrift.ResponseMeta
  _meta58, _err = p.Client_().Call(ctx, "setHazelcastCloudClusterMemberCount", &_args57, &_result59)
  p.SetLastResponseMeta_(_meta58)
  if _err != nil {
    return
  }
  switch {
  case _result59.CloudException!= nil:
    return _result59.CloudException
  }

  return nil
}

// Get information of the given cluster
// @return CloudCluster
// @throws CloudException
// 
// @param cloudClusterId
// 
// Parameters:
//  - CloudClusterId
func (p *RemoteControllerClient) GetHazelcastCloudCluster(ctx context.Context, cloudClusterId string) (_r *CloudCluster, _err error) {
  var _args60 RemoteControllerGetHazelcastCloudClusterArgs
  _args60.CloudClusterId = cloudClusterId
  var _result62 RemoteControllerGetHazelcastCloudClusterResult
  var _meta61 thrift.ResponseMeta
  _meta61, _err = p.Client_().Call(ctx, "getHazelcastCloudCluster", &_args60, &_result62)
  p.SetLastResponseMeta_(_meta61)
  if _err != nil {
    return
  }
  switch {
  case _result62.CloudException!= nil:
    return _r, _result62.CloudException
  }

  if _ret63 := _result62.GetSuccess(); _ret63 != nil {
    return _ret63, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "getHazelcastCloudCluster failed: unknown result")
}

// Stops the given cluster
// @return CloudCluster
// @throws CloudException
// 
// @param cloudClusterId
// 
// Parameters:
//  - CloudClusterId
func (p *RemoteControllerClient) StopHazelcastCloudCluster(ctx context.Context, cloudClusterId string) (_r *CloudCluster, _err error) {
  var _args64 RemoteControllerStopHazelcastCloudClusterArgs
  _args64.CloudClusterId = cloudClusterId
  var _result66 RemoteControllerStopHazelcastCloudClusterResult
  var _meta65 thrift.ResponseMeta
  _meta65, _err = p.Client_().Call(ctx, "stopHazelcastCloudCluster", &_args64, &_result66)
  p.SetLastResponseMeta_(_meta65)
  if _err != nil {
    return
  }
  switch {
  case _result66.CloudException!= nil:
    return _r, _result66.CloudException
  }

  if _ret67 := _result66.GetSuccess(); _ret67 != nil {
    return _ret67, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "stopHazelcastCloudCluster failed: unknown result")
}

// Resumes the given cluster
// @return CloudCluster
// @throws CloudException
// 
// @param cloudClusterId
// 
// Parameters:
//  - CloudClusterId
func (p *RemoteControllerClient) ResumeHazelcastCloudCluster(ctx context.Context, cloudClusterId string) (_r *CloudCluster, _err error) {
  var _args68 RemoteControllerResumeHazelcastCloudClusterArgs
  _args68.CloudClusterId = cloudClusterId
  var _result70 RemoteControllerResumeHazelcastCloudClusterResult
  var _meta69 thrift.ResponseMeta
  _meta69, _err = p.Client_().Call(ctx, "resumeHazelcastCloudCluster", &_args68, &_result70)
  p.SetLastResponseMeta_(_meta69)
  if _err != nil {
    return
  }
  switch {
  case _result70.CloudException!= nil:
    return _r, _result70.CloudException
  }

  if _ret71 := _result70.GetSuccess(); _ret71 != nil {
    return _ret71, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "resumeHazelcastCloudCluster failed: unknown result")
}

// Deletes the given cluster
// @return boolean
// @throws CloudException
// 
// @param cloudClusterId
// 
// Parameters:
//  - CloudClusterId
func (p *RemoteControllerClient) DeleteHazelcastCloudCluster(ctx context.Context, cloudClusterId string) (_err error) {
  var _args72 RemoteControllerDeleteHazelcastCloudClusterArgs
  _args72.CloudClusterId = cloudClusterId
  var _result74 RemoteControllerDeleteHazelcastCloudClusterResult
  var _meta73 thrift.ResponseMeta
  _meta73, _err = p.Client_().Call(ctx, "deleteHazelcastCloudCluster", &_args72, &_result74)
  p.SetLastResponseMeta_(_meta73)
  if _err != nil {
    return
  }
  switch {
  case _result74.CloudException!= nil:
    return _result74.CloudException
  }

  return nil
}

// Parameters:
//  - ClusterId
//  - Script
//  - Lang
func (p *RemoteControllerClient) ExecuteOnController(ctx context.Context, clusterId string, script string, lang Lang) (_r *Response, _err error) {
  var _args75 RemoteControllerExecuteOnControllerArgs
  _args75.ClusterId = clusterId
  _args75.Script = script
  _args75.Lang = lang
  var _result77 RemoteControllerExecuteOnControllerResult
  var _meta76 thrift.ResponseMeta
  _meta76, _err = p.Client_().Call(ctx, "executeOnController", &_args75, &_result77)
  p.SetLastResponseMeta_(_meta76)
  if _err != nil {
    return
  }
  if _ret78 := _result77.GetSuccess(); _ret78 != nil {
    return _ret78, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "executeOnController failed: unknown result")
}

type RemoteControllerProcessor struct {
  processorMap map[string]thrift.TProcessorFunction
  handler RemoteController
}

func (p *RemoteControllerProcessor) AddToProcessorMap(key string, processor thrift.TProcessorFunction) {
  p.processorMap[key] = processor
}

func (p *RemoteControllerProcessor) GetProcessorFunction(key string) (processor thrift.TProcessorFunction, ok bool) {
  processor, ok = p.processorMap[key]
  return processor, ok
}

func (p *RemoteControllerProcessor) ProcessorMap() map[string]thrift.TProcessorFunction {
  return p.processorMap
}

func NewRemoteControllerProcessor(handler RemoteController) *RemoteControllerProcessor {

  self79 := &RemoteControllerProcessor{handler:handler, processorMap:make(map[string]thrift.TProcessorFunction)}
  self79.processorMap["ping"] = &remoteControllerProcessorPing{handler:handler}
  self79.processorMap["clean"] = &remoteControllerProcessorClean{handler:handler}
  self79.processorMap["exit"] = &remoteControllerProcessorExit{handler:handler}
  self79.processorMap["createCluster"] = &remoteControllerProcessorCreateCluster{handler:handler}
  self79.processorMap["createClusterKeepClusterName"] = &remoteControllerProcessorCreateClusterKeepClusterName{handler:handler}
  self79.processorMap["startMember"] = &remoteControllerProcessorStartMember{handler:handler}
  self79.processorMap["shutdownMember"] = &remoteControllerProcessorShutdownMember{handler:handler}
  self79.processorMap["terminateMember"] = &remoteControllerProcessorTerminateMember{handler:handler}
  self79.processorMap["suspendMember"] = &remoteControllerProcessorSuspendMember{handler:handler}
  self79.processorMap["resumeMember"] = &remoteControllerProcessorResumeMember{handler:handler}
  self79.processorMap["shutdownCluster"] = &remoteControllerProcessorShutdownCluster{handler:handler}
  self79.processorMap["terminateCluster"] = &remoteControllerProcessorTerminateCluster{handler:handler}
  self79.processorMap["splitMemberFromCluster"] = &remoteControllerProcessorSplitMemberFromCluster{handler:handler}
  self79.processorMap["mergeMemberToCluster"] = &remoteControllerProcessorMergeMemberToCluster{handler:handler}
  self79.processorMap["loginToHazelcastCloudUsingEnvironment"] = &remoteControllerProcessorLoginToHazelcastCloudUsingEnvironment{handler:handler}
  self79.processorMap["loginToHazelcastCloud"] = &remoteControllerProcessorLoginToHazelcastCloud{handler:handler}
  self79.processorMap["createHazelcastCloudStandardCluster"] = &remoteControllerProcessorCreateHazelcastCloudStandardCluster{handler:handler}
  self79.processorMap["setHazelcastCloudClusterMemberCount"] = &remoteControllerProcessorSetHazelcastCloudClusterMemberCount{handler:handler}
  self79.processorMap["getHazelcastCloudCluster"] = &remoteControllerProcessorGetHazelcastCloudCluster{handler:handler}
  self79.processorMap["stopHazelcastCloudCluster"] = &remoteControllerProcessorStopHazelcastCloudCluster{handler:handler}
  self79.processorMap["resumeHazelcastCloudCluster"] = &remoteControllerProcessorResumeHazelcastCloudCluster{handler:handler}
  self79.processorMap["deleteHazelcastCloudCluster"] = &remoteControllerProcessorDeleteHazelcastCloudCluster{handler:handler}
  self79.processorMap["executeOnController"] = &remoteControllerProcessorExecuteOnController{handler:handler}
return self79
}

func (p *RemoteControllerProcessor) Process(ctx context.Context, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  name, _, seqId, err2 := iprot.ReadMessageBegin(ctx)
  if err2 != nil { return false, thrift.WrapTException(err2) }
  if processor, ok := p.GetProcessorFunction(name); ok {
    return processor.Process(ctx, seqId, iprot, oprot)
  }
  iprot.Skip(ctx, thrift.STRUCT)
  iprot.ReadMessageEnd(ctx)
  x80 := thrift.NewTApplicationException(thrift.UNKNOWN_METHOD, "Unknown function " + name)
  oprot.WriteMessageBegin(ctx, name, thrift.EXCEPTION, seqId)
  x80.Write(ctx, oprot)
  oprot.WriteMessageEnd(ctx)
  oprot.Flush(ctx)
  return false, x80

}

type remoteControllerProcessorPing struct {
  handler RemoteController
}

func (p *remoteControllerProcessorPing) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := RemoteControllerPingArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "ping", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := RemoteControllerPingResult{}
  var retval bool
  if retval, err2 = p.handler.Ping(ctx); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing ping: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "ping", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "ping", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type remoteControllerProcessorClean struct {
  handler RemoteController
}

func (p *remoteControllerProcessorClean) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := RemoteControllerCleanArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "clean", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := RemoteControllerCleanResult{}
  var retval bool
  if retval, err2 = p.handler.Clean(ctx); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing clean: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "clean", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "clean", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type remoteControllerProcessorExit struct {
  handler RemoteController
}

func (p *remoteControllerProcessorExit) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := RemoteControllerExitArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "exit", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := RemoteControllerExitResult{}
  var retval bool
  if retval, err2 = p.handler.Exit(ctx); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing exit: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "exit", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "exit", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type remoteControllerProcessorCreateCluster struct {
  handler RemoteController
}

func (p *remoteControllerProcessorCreateCluster) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := RemoteControllerCreateClusterArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "createCluster", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := RemoteControllerCreateClusterResult{}
  var retval *Cluster
  if retval, err2 = p.handler.CreateCluster(ctx, args.HzVersion, args.Xmlconfig); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *ServerException:
  result.ServerException = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing createCluster: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "createCluster", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "createCluster", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type remoteControllerProcessorCreateClusterKeepClusterName struct {
  handler RemoteController
}

func (p *remoteControllerProcessorCreateClusterKeepClusterName) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := RemoteControllerCreateClusterKeepClusterNameArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "createClusterKeepClusterName", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := RemoteControllerCreateClusterKeepClusterNameResult{}
  var retval *Cluster
  if retval, err2 = p.handler.CreateClusterKeepClusterName(ctx, args.HzVersion, args.Xmlconfig); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *ServerException:
  result.ServerException = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing createClusterKeepClusterName: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "createClusterKeepClusterName", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "createClusterKeepClusterName", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type remoteControllerProcessorStartMember struct {
  handler RemoteController
}

func (p *remoteControllerProcessorStartMember) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := RemoteControllerStartMemberArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "startMember", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := RemoteControllerStartMemberResult{}
  var retval *Member
  if retval, err2 = p.handler.StartMember(ctx, args.ClusterId); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *ServerException:
  result.ServerException = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing startMember: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "startMember", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "startMember", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type remoteControllerProcessorShutdownMember struct {
  handler RemoteController
}

func (p *remoteControllerProcessorShutdownMember) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := RemoteControllerShutdownMemberArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "shutdownMember", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := RemoteControllerShutdownMemberResult{}
  var retval bool
  if retval, err2 = p.handler.ShutdownMember(ctx, args.ClusterId, args.MemberId); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing shutdownMember: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "shutdownMember", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "shutdownMember", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type remoteControllerProcessorTerminateMember struct {
  handler RemoteController
}

func (p *remoteControllerProcessorTerminateMember) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := RemoteControllerTerminateMemberArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "terminateMember", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := RemoteControllerTerminateMemberResult{}
  var retval bool
  if retval, err2 = p.handler.TerminateMember(ctx, args.ClusterId, args.MemberId); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing terminateMember: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "terminateMember", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "terminateMember", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type remoteControllerProcessorSuspendMember struct {
  handler RemoteController
}

func (p *remoteControllerProcessorSuspendMember) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := RemoteControllerSuspendMemberArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "suspendMember", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := RemoteControllerSuspendMemberResult{}
  var retval bool
  if retval, err2 = p.handler.SuspendMember(ctx, args.ClusterId, args.MemberId); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing suspendMember: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "suspendMember", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "suspendMember", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type remoteControllerProcessorResumeMember struct {
  handler RemoteController
}

func (p *remoteControllerProcessorResumeMember) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := RemoteControllerResumeMemberArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "resumeMember", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := RemoteControllerResumeMemberResult{}
  var retval bool
  if retval, err2 = p.handler.ResumeMember(ctx, args.ClusterId, args.MemberId); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing resumeMember: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "resumeMember", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "resumeMember", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type remoteControllerProcessorShutdownCluster struct {
  handler RemoteController
}

func (p *remoteControllerProcessorShutdownCluster) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := RemoteControllerShutdownClusterArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "shutdownCluster", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := RemoteControllerShutdownClusterResult{}
  var retval bool
  if retval, err2 = p.handler.ShutdownCluster(ctx, args.ClusterId); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing shutdownCluster: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "shutdownCluster", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "shutdownCluster", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type remoteControllerProcessorTerminateCluster struct {
  handler RemoteController
}

func (p *remoteControllerProcessorTerminateCluster) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := RemoteControllerTerminateClusterArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "terminateCluster", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := RemoteControllerTerminateClusterResult{}
  var retval bool
  if retval, err2 = p.handler.TerminateCluster(ctx, args.ClusterId); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing terminateCluster: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "terminateCluster", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "terminateCluster", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type remoteControllerProcessorSplitMemberFromCluster struct {
  handler RemoteController
}

func (p *remoteControllerProcessorSplitMemberFromCluster) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := RemoteControllerSplitMemberFromClusterArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "splitMemberFromCluster", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := RemoteControllerSplitMemberFromClusterResult{}
  var retval *Cluster
  if retval, err2 = p.handler.SplitMemberFromCluster(ctx, args.MemberId); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing splitMemberFromCluster: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "splitMemberFromCluster", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "splitMemberFromCluster", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type remoteControllerProcessorMergeMemberToCluster struct {
  handler RemoteController
}

func (p *remoteControllerProcessorMergeMemberToCluster) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := RemoteControllerMergeMemberToClusterArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "mergeMemberToCluster", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := RemoteControllerMergeMemberToClusterResult{}
  var retval *Cluster
  if retval, err2 = p.handler.MergeMemberToCluster(ctx, args.ClusterId, args.MemberId); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing mergeMemberToCluster: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "mergeMemberToCluster", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "mergeMemberToCluster", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type remoteControllerProcessorLoginToHazelcastCloudUsingEnvironment struct {
  handler RemoteController
}

func (p *remoteControllerProcessorLoginToHazelcastCloudUsingEnvironment) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := RemoteControllerLoginToHazelcastCloudUsingEnvironmentArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "loginToHazelcastCloudUsingEnvironment", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := RemoteControllerLoginToHazelcastCloudUsingEnvironmentResult{}
  if err2 = p.handler.LoginToHazelcastCloudUsingEnvironment(ctx); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *CloudException:
  result.CloudException = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing loginToHazelcastCloudUsingEnvironment: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "loginToHazelcastCloudUsingEnvironment", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "loginToHazelcastCloudUsingEnvironment", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type remoteControllerProcessorLoginToHazelcastCloud struct {
  handler RemoteController
}

func (p *remoteControllerProcessorLoginToHazelcastCloud) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := RemoteControllerLoginToHazelcastCloudArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "loginToHazelcastCloud", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := RemoteControllerLoginToHazelcastCloudResult{}
  if err2 = p.handler.LoginToHazelcastCloud(ctx, args.BaseUrl, args.ApiKey, args.ApiSecret); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *CloudException:
  result.CloudException = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing loginToHazelcastCloud: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "loginToHazelcastCloud", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "loginToHazelcastCloud", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type remoteControllerProcessorCreateHazelcastCloudStandardCluster struct {
  handler RemoteController
}

func (p *remoteControllerProcessorCreateHazelcastCloudStandardCluster) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := RemoteControllerCreateHazelcastCloudStandardClusterArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "createHazelcastCloudStandardCluster", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := RemoteControllerCreateHazelcastCloudStandardClusterResult{}
  var retval *CloudCluster
  if retval, err2 = p.handler.CreateHazelcastCloudStandardCluster(ctx, args.HazelcastVersion, args.IsTlsEnabled); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *CloudException:
  result.CloudException = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing createHazelcastCloudStandardCluster: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "createHazelcastCloudStandardCluster", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "createHazelcastCloudStandardCluster", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type remoteControllerProcessorSetHazelcastCloudClusterMemberCount struct {
  handler RemoteController
}

func (p *remoteControllerProcessorSetHazelcastCloudClusterMemberCount) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := RemoteControllerSetHazelcastCloudClusterMemberCountArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "setHazelcastCloudClusterMemberCount", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := RemoteControllerSetHazelcastCloudClusterMemberCountResult{}
  if err2 = p.handler.SetHazelcastCloudClusterMemberCount(ctx, args.CloudClusterId, args.TotalMemberCount); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *CloudException:
  result.CloudException = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing setHazelcastCloudClusterMemberCount: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "setHazelcastCloudClusterMemberCount", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "setHazelcastCloudClusterMemberCount", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type remoteControllerProcessorGetHazelcastCloudCluster struct {
  handler RemoteController
}

func (p *remoteControllerProcessorGetHazelcastCloudCluster) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := RemoteControllerGetHazelcastCloudClusterArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "getHazelcastCloudCluster", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := RemoteControllerGetHazelcastCloudClusterResult{}
  var retval *CloudCluster
  if retval, err2 = p.handler.GetHazelcastCloudCluster(ctx, args.CloudClusterId); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *CloudException:
  result.CloudException = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getHazelcastCloudCluster: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "getHazelcastCloudCluster", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "getHazelcastCloudCluster", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type remoteControllerProcessorStopHazelcastCloudCluster struct {
  handler RemoteController
}

func (p *remoteControllerProcessorStopHazelcastCloudCluster) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := RemoteControllerStopHazelcastCloudClusterArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "stopHazelcastCloudCluster", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := RemoteControllerStopHazelcastCloudClusterResult{}
  var retval *CloudCluster
  if retval, err2 = p.handler.StopHazelcastCloudCluster(ctx, args.CloudClusterId); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *CloudException:
  result.CloudException = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing stopHazelcastCloudCluster: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "stopHazelcastCloudCluster", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "stopHazelcastCloudCluster", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type remoteControllerProcessorResumeHazelcastCloudCluster struct {
  handler RemoteController
}

func (p *remoteControllerProcessorResumeHazelcastCloudCluster) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := RemoteControllerResumeHazelcastCloudClusterArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "resumeHazelcastCloudCluster", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := RemoteControllerResumeHazelcastCloudClusterResult{}
  var retval *CloudCluster
  if retval, err2 = p.handler.ResumeHazelcastCloudCluster(ctx, args.CloudClusterId); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *CloudException:
  result.CloudException = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing resumeHazelcastCloudCluster: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "resumeHazelcastCloudCluster", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "resumeHazelcastCloudCluster", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type remoteControllerProcessorDeleteHazelcastCloudCluster struct {
  handler RemoteController
}

func (p *remoteControllerProcessorDeleteHazelcastCloudCluster) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := RemoteControllerDeleteHazelcastCloudClusterArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "deleteHazelcastCloudCluster", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := RemoteControllerDeleteHazelcastCloudClusterResult{}
  if err2 = p.handler.DeleteHazelcastCloudCluster(ctx, args.CloudClusterId); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *CloudException:
  result.CloudException = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing deleteHazelcastCloudCluster: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "deleteHazelcastCloudCluster", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "deleteHazelcastCloudCluster", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type remoteControllerProcessorExecuteOnController struct {
  handler RemoteController
}

func (p *remoteControllerProcessorExecuteOnController) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := RemoteControllerExecuteOnControllerArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "executeOnController", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := RemoteControllerExecuteOnControllerResult{}
  var retval *Response
  if retval, err2 = p.handler.ExecuteOnController(ctx, args.ClusterId, args.Script, args.Lang); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing executeOnController: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "executeOnController", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "executeOnController", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}


// HELPER FUNCTIONS AND STRUCTURES

type RemoteControllerPingArgs struct {
}

func NewRemoteControllerPingArgs() *RemoteControllerPingArgs {
  return &RemoteControllerPingArgs{}
}

func (p *RemoteControllerPingArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *RemoteControllerPingArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "ping_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *RemoteControllerPingArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("RemoteControllerPingArgs(%+v)", *p)
}

// Attributes:
//  - Success
type RemoteControllerPingResult struct {
  Success *bool `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewRemoteControllerPingResult() *RemoteControllerPingResult {
  return &RemoteControllerPingResult{}
}

var RemoteControllerPingResult_Success_DEFAULT bool
func (p *RemoteControllerPingResult) GetSuccess() bool {
  if !p.IsSetSuccess() {
    return RemoteControllerPingResult_Success_DEFAULT
  }
return *p.Success
}
func (p *RemoteControllerPingResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *RemoteControllerPingResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *RemoteControllerPingResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *RemoteControllerPingResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "ping_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *RemoteControllerPingResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.BOOL, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *RemoteControllerPingResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("RemoteControllerPingResult(%+v)", *p)
}

type RemoteControllerCleanArgs struct {
}

func NewRemoteControllerCleanArgs() *RemoteControllerCleanArgs {
  return &RemoteControllerCleanArgs{}
}

func (p *RemoteControllerCleanArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *RemoteControllerCleanArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "clean_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *RemoteControllerCleanArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("RemoteControllerCleanArgs(%+v)", *p)
}

// Attributes:
//  - Success
type RemoteControllerCleanResult struct {
  Success *bool `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewRemoteControllerCleanResult() *RemoteControllerCleanResult {
  return &RemoteControllerCleanResult{}
}

var RemoteControllerCleanResult_Success_DEFAULT bool
func (p *RemoteControllerCleanResult) GetSuccess() bool {
  if !p.IsSetSuccess() {
    return RemoteControllerCleanResult_Success_DEFAULT
  }
return *p.Success
}
func (p *RemoteControllerCleanResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *RemoteControllerCleanResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *RemoteControllerCleanResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *RemoteControllerCleanResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "clean_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *RemoteControllerCleanResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.BOOL, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *RemoteControllerCleanResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("RemoteControllerCleanResult(%+v)", *p)
}

type RemoteControllerExitArgs struct {
}

func NewRemoteControllerExitArgs() *RemoteControllerExitArgs {
  return &RemoteControllerExitArgs{}
}

func (p *RemoteControllerExitArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *RemoteControllerExitArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "exit_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *RemoteControllerExitArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("RemoteControllerExitArgs(%+v)", *p)
}

// Attributes:
//  - Success
type RemoteControllerExitResult struct {
  Success *bool `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewRemoteControllerExitResult() *RemoteControllerExitResult {
  return &RemoteControllerExitResult{}
}

var RemoteControllerExitResult_Success_DEFAULT bool
func (p *RemoteControllerExitResult) GetSuccess() bool {
  if !p.IsSetSuccess() {
    return RemoteControllerExitResult_Success_DEFAULT
  }
return *p.Success
}
func (p *RemoteControllerExitResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *RemoteControllerExitResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *RemoteControllerExitResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *RemoteControllerExitResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "exit_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *RemoteControllerExitResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.BOOL, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *RemoteControllerExitResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("RemoteControllerExitResult(%+v)", *p)
}

// Attributes:
//  - HzVersion
//  - Xmlconfig
type RemoteControllerCreateClusterArgs struct {
  HzVersion string `thrift:"hzVersion,1" db:"hzVersion" json:"hzVersion"`
  Xmlconfig string `thrift:"xmlconfig,2" db:"xmlconfig" json:"xmlconfig"`
}

func NewRemoteControllerCreateClusterArgs() *RemoteControllerCreateClusterArgs {
  return &RemoteControllerCreateClusterArgs{}
}


func (p *RemoteControllerCreateClusterArgs) GetHzVersion() string {
  return p.HzVersion
}

func (p *RemoteControllerCreateClusterArgs) GetXmlconfig() string {
  return p.Xmlconfig
}
func (p *RemoteControllerCreateClusterArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *RemoteControllerCreateClusterArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.HzVersion = v
}
  return nil
}

func (p *RemoteControllerCreateClusterArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Xmlconfig = v
}
  return nil
}

func (p *RemoteControllerCreateClusterArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "createCluster_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *RemoteControllerCreateClusterArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "hzVersion", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:hzVersion: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.HzVersion)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.hzVersion (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:hzVersion: ", p), err) }
  return err
}

func (p *RemoteControllerCreateClusterArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "xmlconfig", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:xmlconfig: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Xmlconfig)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.xmlconfig (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:xmlconfig: ", p), err) }
  return err
}

func (p *RemoteControllerCreateClusterArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("RemoteControllerCreateClusterArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - ServerException
type RemoteControllerCreateClusterResult struct {
  Success *Cluster `thrift:"success,0" db:"success" json:"success,omitempty"`
  ServerException *ServerException `thrift:"serverException,1" db:"serverException" json:"serverException,omitempty"`
}

func NewRemoteControllerCreateClusterResult() *RemoteControllerCreateClusterResult {
  return &RemoteControllerCreateClusterResult{}
}

var RemoteControllerCreateClusterResult_Success_DEFAULT *Cluster
func (p *RemoteControllerCreateClusterResult) GetSuccess() *Cluster {
  if !p.IsSetSuccess() {
    return RemoteControllerCreateClusterResult_Success_DEFAULT
  }
return p.Success
}
var RemoteControllerCreateClusterResult_ServerException_DEFAULT *ServerException
func (p *RemoteControllerCreateClusterResult) GetServerException() *ServerException {
  if !p.IsSetServerException() {
    return RemoteControllerCreateClusterResult_ServerException_DEFAULT
  }
return p.ServerException
}
func (p *RemoteControllerCreateClusterResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *RemoteControllerCreateClusterResult) IsSetServerException() bool {
  return p.ServerException != nil
}

func (p *RemoteControllerCreateClusterResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *RemoteControllerCreateClusterResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &Cluster{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *RemoteControllerCreateClusterResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.ServerException = &ServerException{}
  if err := p.ServerException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.ServerException), err)
  }
  return nil
}

func (p *RemoteControllerCreateClusterResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "createCluster_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *RemoteControllerCreateClusterResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *RemoteControllerCreateClusterResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetServerException() {
    if err := oprot.WriteFieldBegin(ctx, "serverException", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:serverException: ", p), err) }
    if err := p.ServerException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.ServerException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:serverException: ", p), err) }
  }
  return err
}

func (p *RemoteControllerCreateClusterResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("RemoteControllerCreateClusterResult(%+v)", *p)
}

// Attributes:
//  - HzVersion
//  - Xmlconfig
type RemoteControllerCreateClusterKeepClusterNameArgs struct {
  HzVersion string `thrift:"hzVersion,1" db:"hzVersion" json:"hzVersion"`
  Xmlconfig string `thrift:"xmlconfig,2" db:"xmlconfig" json:"xmlconfig"`
}

func NewRemoteControllerCreateClusterKeepClusterNameArgs() *RemoteControllerCreateClusterKeepClusterNameArgs {
  return &RemoteControllerCreateClusterKeepClusterNameArgs{}
}


func (p *RemoteControllerCreateClusterKeepClusterNameArgs) GetHzVersion() string {
  return p.HzVersion
}

func (p *RemoteControllerCreateClusterKeepClusterNameArgs) GetXmlconfig() string {
  return p.Xmlconfig
}
func (p *RemoteControllerCreateClusterKeepClusterNameArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *RemoteControllerCreateClusterKeepClusterNameArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.HzVersion = v
}
  return nil
}

func (p *RemoteControllerCreateClusterKeepClusterNameArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Xmlconfig = v
}
  return nil
}

func (p *RemoteControllerCreateClusterKeepClusterNameArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "createClusterKeepClusterName_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *RemoteControllerCreateClusterKeepClusterNameArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "hzVersion", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:hzVersion: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.HzVersion)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.hzVersion (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:hzVersion: ", p), err) }
  return err
}

func (p *RemoteControllerCreateClusterKeepClusterNameArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "xmlconfig", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:xmlconfig: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Xmlconfig)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.xmlconfig (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:xmlconfig: ", p), err) }
  return err
}

func (p *RemoteControllerCreateClusterKeepClusterNameArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("RemoteControllerCreateClusterKeepClusterNameArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - ServerException
type RemoteControllerCreateClusterKeepClusterNameResult struct {
  Success *Cluster `thrift:"success,0" db:"success" json:"success,omitempty"`
  ServerException *ServerException `thrift:"serverException,1" db:"serverException" json:"serverException,omitempty"`
}

func NewRemoteControllerCreateClusterKeepClusterNameResult() *RemoteControllerCreateClusterKeepClusterNameResult {
  return &RemoteControllerCreateClusterKeepClusterNameResult{}
}

var RemoteControllerCreateClusterKeepClusterNameResult_Success_DEFAULT *Cluster
func (p *RemoteControllerCreateClusterKeepClusterNameResult) GetSuccess() *Cluster {
  if !p.IsSetSuccess() {
    return RemoteControllerCreateClusterKeepClusterNameResult_Success_DEFAULT
  }
return p.Success
}
var RemoteControllerCreateClusterKeepClusterNameResult_ServerException_DEFAULT *ServerException
func (p *RemoteControllerCreateClusterKeepClusterNameResult) GetServerException() *ServerException {
  if !p.IsSetServerException() {
    return RemoteControllerCreateClusterKeepClusterNameResult_ServerException_DEFAULT
  }
return p.ServerException
}
func (p *RemoteControllerCreateClusterKeepClusterNameResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *RemoteControllerCreateClusterKeepClusterNameResult) IsSetServerException() bool {
  return p.ServerException != nil
}

func (p *RemoteControllerCreateClusterKeepClusterNameResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *RemoteControllerCreateClusterKeepClusterNameResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &Cluster{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *RemoteControllerCreateClusterKeepClusterNameResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.ServerException = &ServerException{}
  if err := p.ServerException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.ServerException), err)
  }
  return nil
}

func (p *RemoteControllerCreateClusterKeepClusterNameResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "createClusterKeepClusterName_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *RemoteControllerCreateClusterKeepClusterNameResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *RemoteControllerCreateClusterKeepClusterNameResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetServerException() {
    if err := oprot.WriteFieldBegin(ctx, "serverException", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:serverException: ", p), err) }
    if err := p.ServerException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.ServerException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:serverException: ", p), err) }
  }
  return err
}

func (p *RemoteControllerCreateClusterKeepClusterNameResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("RemoteControllerCreateClusterKeepClusterNameResult(%+v)", *p)
}

// Attributes:
//  - ClusterId
type RemoteControllerStartMemberArgs struct {
  ClusterId string `thrift:"clusterId,1" db:"clusterId" json:"clusterId"`
}

func NewRemoteControllerStartMemberArgs() *RemoteControllerStartMemberArgs {
  return &RemoteControllerStartMemberArgs{}
}


func (p *RemoteControllerStartMemberArgs) GetClusterId() string {
  return p.ClusterId
}
func (p *RemoteControllerStartMemberArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *RemoteControllerStartMemberArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.ClusterId = v
}
  return nil
}

func (p *RemoteControllerStartMemberArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "startMember_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *RemoteControllerStartMemberArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "clusterId", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:clusterId: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.ClusterId)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.clusterId (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:clusterId: ", p), err) }
  return err
}

func (p *RemoteControllerStartMemberArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("RemoteControllerStartMemberArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - ServerException
type RemoteControllerStartMemberResult struct {
  Success *Member `thrift:"success,0" db:"success" json:"success,omitempty"`
  ServerException *ServerException `thrift:"serverException,1" db:"serverException" json:"serverException,omitempty"`
}

func NewRemoteControllerStartMemberResult() *RemoteControllerStartMemberResult {
  return &RemoteControllerStartMemberResult{}
}

var RemoteControllerStartMemberResult_Success_DEFAULT *Member
func (p *RemoteControllerStartMemberResult) GetSuccess() *Member {
  if !p.IsSetSuccess() {
    return RemoteControllerStartMemberResult_Success_DEFAULT
  }
return p.Success
}
var RemoteControllerStartMemberResult_ServerException_DEFAULT *ServerException
func (p *RemoteControllerStartMemberResult) GetServerException() *ServerException {
  if !p.IsSetServerException() {
    return RemoteControllerStartMemberResult_ServerException_DEFAULT
  }
return p.ServerException
}
func (p *RemoteControllerStartMemberResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *RemoteControllerStartMemberResult) IsSetServerException() bool {
  return p.ServerException != nil
}

func (p *RemoteControllerStartMemberResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *RemoteControllerStartMemberResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &Member{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *RemoteControllerStartMemberResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.ServerException = &ServerException{}
  if err := p.ServerException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.ServerException), err)
  }
  return nil
}

func (p *RemoteControllerStartMemberResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "startMember_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *RemoteControllerStartMemberResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *RemoteControllerStartMemberResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetServerException() {
    if err := oprot.WriteFieldBegin(ctx, "serverException", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:serverException: ", p), err) }
    if err := p.ServerException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.ServerException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:serverException: ", p), err) }
  }
  return err
}

func (p *RemoteControllerStartMemberResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("RemoteControllerStartMemberResult(%+v)", *p)
}

// Attributes:
//  - ClusterId
//  - MemberId
type RemoteControllerShutdownMemberArgs struct {
  ClusterId string `thrift:"clusterId,1" db:"clusterId" json:"clusterId"`
  MemberId string `thrift:"memberId,2" db:"memberId" json:"memberId"`
}

func NewRemoteControllerShutdownMemberArgs() *RemoteControllerShutdownMemberArgs {
  return &RemoteControllerShutdownMemberArgs{}
}


func (p *RemoteControllerShutdownMemberArgs) GetClusterId() string {
  return p.ClusterId
}

func (p *RemoteControllerShutdownMemberArgs) GetMemberId() string {
  return p.MemberId
}
func (p *RemoteControllerShutdownMemberArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *RemoteControllerShutdownMemberArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.ClusterId = v
}
  return nil
}

func (p *RemoteControllerShutdownMemberArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.MemberId = v
}
  return nil
}

func (p *RemoteControllerShutdownMemberArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "shutdownMember_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *RemoteControllerShutdownMemberArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "clusterId", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:clusterId: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.ClusterId)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.clusterId (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:clusterId: ", p), err) }
  return err
}

func (p *RemoteControllerShutdownMemberArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "memberId", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:memberId: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.MemberId)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.memberId (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:memberId: ", p), err) }
  return err
}

func (p *RemoteControllerShutdownMemberArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("RemoteControllerShutdownMemberArgs(%+v)", *p)
}

// Attributes:
//  - Success
type RemoteControllerShutdownMemberResult struct {
  Success *bool `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewRemoteControllerShutdownMemberResult() *RemoteControllerShutdownMemberResult {
  return &RemoteControllerShutdownMemberResult{}
}

var RemoteControllerShutdownMemberResult_Success_DEFAULT bool
func (p *RemoteControllerShutdownMemberResult) GetSuccess() bool {
  if !p.IsSetSuccess() {
    return RemoteControllerShutdownMemberResult_Success_DEFAULT
  }
return *p.Success
}
func (p *RemoteControllerShutdownMemberResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *RemoteControllerShutdownMemberResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *RemoteControllerShutdownMemberResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *RemoteControllerShutdownMemberResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "shutdownMember_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *RemoteControllerShutdownMemberResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.BOOL, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *RemoteControllerShutdownMemberResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("RemoteControllerShutdownMemberResult(%+v)", *p)
}

// Attributes:
//  - ClusterId
//  - MemberId
type RemoteControllerTerminateMemberArgs struct {
  ClusterId string `thrift:"clusterId,1" db:"clusterId" json:"clusterId"`
  MemberId string `thrift:"memberId,2" db:"memberId" json:"memberId"`
}

func NewRemoteControllerTerminateMemberArgs() *RemoteControllerTerminateMemberArgs {
  return &RemoteControllerTerminateMemberArgs{}
}


func (p *RemoteControllerTerminateMemberArgs) GetClusterId() string {
  return p.ClusterId
}

func (p *RemoteControllerTerminateMemberArgs) GetMemberId() string {
  return p.MemberId
}
func (p *RemoteControllerTerminateMemberArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *RemoteControllerTerminateMemberArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.ClusterId = v
}
  return nil
}

func (p *RemoteControllerTerminateMemberArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.MemberId = v
}
  return nil
}

func (p *RemoteControllerTerminateMemberArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "terminateMember_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *RemoteControllerTerminateMemberArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "clusterId", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:clusterId: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.ClusterId)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.clusterId (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:clusterId: ", p), err) }
  return err
}

func (p *RemoteControllerTerminateMemberArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "memberId", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:memberId: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.MemberId)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.memberId (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:memberId: ", p), err) }
  return err
}

func (p *RemoteControllerTerminateMemberArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("RemoteControllerTerminateMemberArgs(%+v)", *p)
}

// Attributes:
//  - Success
type RemoteControllerTerminateMemberResult struct {
  Success *bool `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewRemoteControllerTerminateMemberResult() *RemoteControllerTerminateMemberResult {
  return &RemoteControllerTerminateMemberResult{}
}

var RemoteControllerTerminateMemberResult_Success_DEFAULT bool
func (p *RemoteControllerTerminateMemberResult) GetSuccess() bool {
  if !p.IsSetSuccess() {
    return RemoteControllerTerminateMemberResult_Success_DEFAULT
  }
return *p.Success
}
func (p *RemoteControllerTerminateMemberResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *RemoteControllerTerminateMemberResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *RemoteControllerTerminateMemberResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *RemoteControllerTerminateMemberResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "terminateMember_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *RemoteControllerTerminateMemberResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.BOOL, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *RemoteControllerTerminateMemberResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("RemoteControllerTerminateMemberResult(%+v)", *p)
}

// Attributes:
//  - ClusterId
//  - MemberId
type RemoteControllerSuspendMemberArgs struct {
  ClusterId string `thrift:"clusterId,1" db:"clusterId" json:"clusterId"`
  MemberId string `thrift:"memberId,2" db:"memberId" json:"memberId"`
}

func NewRemoteControllerSuspendMemberArgs() *RemoteControllerSuspendMemberArgs {
  return &RemoteControllerSuspendMemberArgs{}
}


func (p *RemoteControllerSuspendMemberArgs) GetClusterId() string {
  return p.ClusterId
}

func (p *RemoteControllerSuspendMemberArgs) GetMemberId() string {
  return p.MemberId
}
func (p *RemoteControllerSuspendMemberArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *RemoteControllerSuspendMemberArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.ClusterId = v
}
  return nil
}

func (p *RemoteControllerSuspendMemberArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.MemberId = v
}
  return nil
}

func (p *RemoteControllerSuspendMemberArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "suspendMember_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *RemoteControllerSuspendMemberArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "clusterId", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:clusterId: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.ClusterId)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.clusterId (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:clusterId: ", p), err) }
  return err
}

func (p *RemoteControllerSuspendMemberArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "memberId", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:memberId: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.MemberId)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.memberId (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:memberId: ", p), err) }
  return err
}

func (p *RemoteControllerSuspendMemberArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("RemoteControllerSuspendMemberArgs(%+v)", *p)
}

// Attributes:
//  - Success
type RemoteControllerSuspendMemberResult struct {
  Success *bool `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewRemoteControllerSuspendMemberResult() *RemoteControllerSuspendMemberResult {
  return &RemoteControllerSuspendMemberResult{}
}

var RemoteControllerSuspendMemberResult_Success_DEFAULT bool
func (p *RemoteControllerSuspendMemberResult) GetSuccess() bool {
  if !p.IsSetSuccess() {
    return RemoteControllerSuspendMemberResult_Success_DEFAULT
  }
return *p.Success
}
func (p *RemoteControllerSuspendMemberResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *RemoteControllerSuspendMemberResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *RemoteControllerSuspendMemberResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *RemoteControllerSuspendMemberResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "suspendMember_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *RemoteControllerSuspendMemberResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.BOOL, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *RemoteControllerSuspendMemberResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("RemoteControllerSuspendMemberResult(%+v)", *p)
}

// Attributes:
//  - ClusterId
//  - MemberId
type RemoteControllerResumeMemberArgs struct {
  ClusterId string `thrift:"clusterId,1" db:"clusterId" json:"clusterId"`
  MemberId string `thrift:"memberId,2" db:"memberId" json:"memberId"`
}

func NewRemoteControllerResumeMemberArgs() *RemoteControllerResumeMemberArgs {
  return &RemoteControllerResumeMemberArgs{}
}


func (p *RemoteControllerResumeMemberArgs) GetClusterId() string {
  return p.ClusterId
}

func (p *RemoteControllerResumeMemberArgs) GetMemberId() string {
  return p.MemberId
}
func (p *RemoteControllerResumeMemberArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *RemoteControllerResumeMemberArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.ClusterId = v
}
  return nil
}

func (p *RemoteControllerResumeMemberArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.MemberId = v
}
  return nil
}

func (p *RemoteControllerResumeMemberArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "resumeMember_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *RemoteControllerResumeMemberArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "clusterId", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:clusterId: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.ClusterId)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.clusterId (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:clusterId: ", p), err) }
  return err
}

func (p *RemoteControllerResumeMemberArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "memberId", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:memberId: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.MemberId)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.memberId (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:memberId: ", p), err) }
  return err
}

func (p *RemoteControllerResumeMemberArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("RemoteControllerResumeMemberArgs(%+v)", *p)
}

// Attributes:
//  - Success
type RemoteControllerResumeMemberResult struct {
  Success *bool `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewRemoteControllerResumeMemberResult() *RemoteControllerResumeMemberResult {
  return &RemoteControllerResumeMemberResult{}
}

var RemoteControllerResumeMemberResult_Success_DEFAULT bool
func (p *RemoteControllerResumeMemberResult) GetSuccess() bool {
  if !p.IsSetSuccess() {
    return RemoteControllerResumeMemberResult_Success_DEFAULT
  }
return *p.Success
}
func (p *RemoteControllerResumeMemberResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *RemoteControllerResumeMemberResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *RemoteControllerResumeMemberResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *RemoteControllerResumeMemberResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "resumeMember_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *RemoteControllerResumeMemberResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.BOOL, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *RemoteControllerResumeMemberResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("RemoteControllerResumeMemberResult(%+v)", *p)
}

// Attributes:
//  - ClusterId
type RemoteControllerShutdownClusterArgs struct {
  ClusterId string `thrift:"clusterId,1" db:"clusterId" json:"clusterId"`
}

func NewRemoteControllerShutdownClusterArgs() *RemoteControllerShutdownClusterArgs {
  return &RemoteControllerShutdownClusterArgs{}
}


func (p *RemoteControllerShutdownClusterArgs) GetClusterId() string {
  return p.ClusterId
}
func (p *RemoteControllerShutdownClusterArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *RemoteControllerShutdownClusterArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.ClusterId = v
}
  return nil
}

func (p *RemoteControllerShutdownClusterArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "shutdownCluster_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *RemoteControllerShutdownClusterArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "clusterId", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:clusterId: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.ClusterId)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.clusterId (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:clusterId: ", p), err) }
  return err
}

func (p *RemoteControllerShutdownClusterArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("RemoteControllerShutdownClusterArgs(%+v)", *p)
}

// Attributes:
//  - Success
type RemoteControllerShutdownClusterResult struct {
  Success *bool `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewRemoteControllerShutdownClusterResult() *RemoteControllerShutdownClusterResult {
  return &RemoteControllerShutdownClusterResult{}
}

var RemoteControllerShutdownClusterResult_Success_DEFAULT bool
func (p *RemoteControllerShutdownClusterResult) GetSuccess() bool {
  if !p.IsSetSuccess() {
    return RemoteControllerShutdownClusterResult_Success_DEFAULT
  }
return *p.Success
}
func (p *RemoteControllerShutdownClusterResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *RemoteControllerShutdownClusterResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *RemoteControllerShutdownClusterResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *RemoteControllerShutdownClusterResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "shutdownCluster_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *RemoteControllerShutdownClusterResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.BOOL, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *RemoteControllerShutdownClusterResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("RemoteControllerShutdownClusterResult(%+v)", *p)
}

// Attributes:
//  - ClusterId
type RemoteControllerTerminateClusterArgs struct {
  ClusterId string `thrift:"clusterId,1" db:"clusterId" json:"clusterId"`
}

func NewRemoteControllerTerminateClusterArgs() *RemoteControllerTerminateClusterArgs {
  return &RemoteControllerTerminateClusterArgs{}
}


func (p *RemoteControllerTerminateClusterArgs) GetClusterId() string {
  return p.ClusterId
}
func (p *RemoteControllerTerminateClusterArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *RemoteControllerTerminateClusterArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.ClusterId = v
}
  return nil
}

func (p *RemoteControllerTerminateClusterArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "terminateCluster_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *RemoteControllerTerminateClusterArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "clusterId", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:clusterId: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.ClusterId)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.clusterId (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:clusterId: ", p), err) }
  return err
}

func (p *RemoteControllerTerminateClusterArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("RemoteControllerTerminateClusterArgs(%+v)", *p)
}

// Attributes:
//  - Success
type RemoteControllerTerminateClusterResult struct {
  Success *bool `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewRemoteControllerTerminateClusterResult() *RemoteControllerTerminateClusterResult {
  return &RemoteControllerTerminateClusterResult{}
}

var RemoteControllerTerminateClusterResult_Success_DEFAULT bool
func (p *RemoteControllerTerminateClusterResult) GetSuccess() bool {
  if !p.IsSetSuccess() {
    return RemoteControllerTerminateClusterResult_Success_DEFAULT
  }
return *p.Success
}
func (p *RemoteControllerTerminateClusterResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *RemoteControllerTerminateClusterResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *RemoteControllerTerminateClusterResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *RemoteControllerTerminateClusterResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "terminateCluster_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *RemoteControllerTerminateClusterResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.BOOL, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *RemoteControllerTerminateClusterResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("RemoteControllerTerminateClusterResult(%+v)", *p)
}

// Attributes:
//  - MemberId
type RemoteControllerSplitMemberFromClusterArgs struct {
  MemberId string `thrift:"memberId,1" db:"memberId" json:"memberId"`
}

func NewRemoteControllerSplitMemberFromClusterArgs() *RemoteControllerSplitMemberFromClusterArgs {
  return &RemoteControllerSplitMemberFromClusterArgs{}
}


func (p *RemoteControllerSplitMemberFromClusterArgs) GetMemberId() string {
  return p.MemberId
}
func (p *RemoteControllerSplitMemberFromClusterArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *RemoteControllerSplitMemberFromClusterArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.MemberId = v
}
  return nil
}

func (p *RemoteControllerSplitMemberFromClusterArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "splitMemberFromCluster_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *RemoteControllerSplitMemberFromClusterArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "memberId", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:memberId: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.MemberId)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.memberId (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:memberId: ", p), err) }
  return err
}

func (p *RemoteControllerSplitMemberFromClusterArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("RemoteControllerSplitMemberFromClusterArgs(%+v)", *p)
}

// Attributes:
//  - Success
type RemoteControllerSplitMemberFromClusterResult struct {
  Success *Cluster `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewRemoteControllerSplitMemberFromClusterResult() *RemoteControllerSplitMemberFromClusterResult {
  return &RemoteControllerSplitMemberFromClusterResult{}
}

var RemoteControllerSplitMemberFromClusterResult_Success_DEFAULT *Cluster
func (p *RemoteControllerSplitMemberFromClusterResult) GetSuccess() *Cluster {
  if !p.IsSetSuccess() {
    return RemoteControllerSplitMemberFromClusterResult_Success_DEFAULT
  }
return p.Success
}
func (p *RemoteControllerSplitMemberFromClusterResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *RemoteControllerSplitMemberFromClusterResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *RemoteControllerSplitMemberFromClusterResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &Cluster{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *RemoteControllerSplitMemberFromClusterResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "splitMemberFromCluster_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *RemoteControllerSplitMemberFromClusterResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *RemoteControllerSplitMemberFromClusterResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("RemoteControllerSplitMemberFromClusterResult(%+v)", *p)
}

// Attributes:
//  - ClusterId
//  - MemberId
type RemoteControllerMergeMemberToClusterArgs struct {
  ClusterId string `thrift:"clusterId,1" db:"clusterId" json:"clusterId"`
  MemberId string `thrift:"memberId,2" db:"memberId" json:"memberId"`
}

func NewRemoteControllerMergeMemberToClusterArgs() *RemoteControllerMergeMemberToClusterArgs {
  return &RemoteControllerMergeMemberToClusterArgs{}
}


func (p *RemoteControllerMergeMemberToClusterArgs) GetClusterId() string {
  return p.ClusterId
}

func (p *RemoteControllerMergeMemberToClusterArgs) GetMemberId() string {
  return p.MemberId
}
func (p *RemoteControllerMergeMemberToClusterArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *RemoteControllerMergeMemberToClusterArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.ClusterId = v
}
  return nil
}

func (p *RemoteControllerMergeMemberToClusterArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.MemberId = v
}
  return nil
}

func (p *RemoteControllerMergeMemberToClusterArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "mergeMemberToCluster_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *RemoteControllerMergeMemberToClusterArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "clusterId", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:clusterId: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.ClusterId)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.clusterId (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:clusterId: ", p), err) }
  return err
}

func (p *RemoteControllerMergeMemberToClusterArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "memberId", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:memberId: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.MemberId)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.memberId (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:memberId: ", p), err) }
  return err
}

func (p *RemoteControllerMergeMemberToClusterArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("RemoteControllerMergeMemberToClusterArgs(%+v)", *p)
}

// Attributes:
//  - Success
type RemoteControllerMergeMemberToClusterResult struct {
  Success *Cluster `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewRemoteControllerMergeMemberToClusterResult() *RemoteControllerMergeMemberToClusterResult {
  return &RemoteControllerMergeMemberToClusterResult{}
}

var RemoteControllerMergeMemberToClusterResult_Success_DEFAULT *Cluster
func (p *RemoteControllerMergeMemberToClusterResult) GetSuccess() *Cluster {
  if !p.IsSetSuccess() {
    return RemoteControllerMergeMemberToClusterResult_Success_DEFAULT
  }
return p.Success
}
func (p *RemoteControllerMergeMemberToClusterResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *RemoteControllerMergeMemberToClusterResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *RemoteControllerMergeMemberToClusterResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &Cluster{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *RemoteControllerMergeMemberToClusterResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "mergeMemberToCluster_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *RemoteControllerMergeMemberToClusterResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *RemoteControllerMergeMemberToClusterResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("RemoteControllerMergeMemberToClusterResult(%+v)", *p)
}

type RemoteControllerLoginToHazelcastCloudUsingEnvironmentArgs struct {
}

func NewRemoteControllerLoginToHazelcastCloudUsingEnvironmentArgs() *RemoteControllerLoginToHazelcastCloudUsingEnvironmentArgs {
  return &RemoteControllerLoginToHazelcastCloudUsingEnvironmentArgs{}
}

func (p *RemoteControllerLoginToHazelcastCloudUsingEnvironmentArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *RemoteControllerLoginToHazelcastCloudUsingEnvironmentArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "loginToHazelcastCloudUsingEnvironment_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *RemoteControllerLoginToHazelcastCloudUsingEnvironmentArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("RemoteControllerLoginToHazelcastCloudUsingEnvironmentArgs(%+v)", *p)
}

// Attributes:
//  - CloudException
type RemoteControllerLoginToHazelcastCloudUsingEnvironmentResult struct {
  CloudException *CloudException `thrift:"cloudException,1" db:"cloudException" json:"cloudException,omitempty"`
}

func NewRemoteControllerLoginToHazelcastCloudUsingEnvironmentResult() *RemoteControllerLoginToHazelcastCloudUsingEnvironmentResult {
  return &RemoteControllerLoginToHazelcastCloudUsingEnvironmentResult{}
}

var RemoteControllerLoginToHazelcastCloudUsingEnvironmentResult_CloudException_DEFAULT *CloudException
func (p *RemoteControllerLoginToHazelcastCloudUsingEnvironmentResult) GetCloudException() *CloudException {
  if !p.IsSetCloudException() {
    return RemoteControllerLoginToHazelcastCloudUsingEnvironmentResult_CloudException_DEFAULT
  }
return p.CloudException
}
func (p *RemoteControllerLoginToHazelcastCloudUsingEnvironmentResult) IsSetCloudException() bool {
  return p.CloudException != nil
}

func (p *RemoteControllerLoginToHazelcastCloudUsingEnvironmentResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *RemoteControllerLoginToHazelcastCloudUsingEnvironmentResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.CloudException = &CloudException{}
  if err := p.CloudException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.CloudException), err)
  }
  return nil
}

func (p *RemoteControllerLoginToHazelcastCloudUsingEnvironmentResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "loginToHazelcastCloudUsingEnvironment_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *RemoteControllerLoginToHazelcastCloudUsingEnvironmentResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetCloudException() {
    if err := oprot.WriteFieldBegin(ctx, "cloudException", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:cloudException: ", p), err) }
    if err := p.CloudException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.CloudException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:cloudException: ", p), err) }
  }
  return err
}

func (p *RemoteControllerLoginToHazelcastCloudUsingEnvironmentResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("RemoteControllerLoginToHazelcastCloudUsingEnvironmentResult(%+v)", *p)
}

// Attributes:
//  - BaseUrl
//  - ApiKey
//  - ApiSecret
type RemoteControllerLoginToHazelcastCloudArgs struct {
  BaseUrl string `thrift:"baseUrl,1" db:"baseUrl" json:"baseUrl"`
  ApiKey string `thrift:"apiKey,2" db:"apiKey" json:"apiKey"`
  ApiSecret string `thrift:"apiSecret,3" db:"apiSecret" json:"apiSecret"`
}

func NewRemoteControllerLoginToHazelcastCloudArgs() *RemoteControllerLoginToHazelcastCloudArgs {
  return &RemoteControllerLoginToHazelcastCloudArgs{}
}


func (p *RemoteControllerLoginToHazelcastCloudArgs) GetBaseUrl() string {
  return p.BaseUrl
}

func (p *RemoteControllerLoginToHazelcastCloudArgs) GetApiKey() string {
  return p.ApiKey
}

func (p *RemoteControllerLoginToHazelcastCloudArgs) GetApiSecret() string {
  return p.ApiSecret
}
func (p *RemoteControllerLoginToHazelcastCloudArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *RemoteControllerLoginToHazelcastCloudArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.BaseUrl = v
}
  return nil
}

func (p *RemoteControllerLoginToHazelcastCloudArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.ApiKey = v
}
  return nil
}

func (p *RemoteControllerLoginToHazelcastCloudArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.ApiSecret = v
}
  return nil
}

func (p *RemoteControllerLoginToHazelcastCloudArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "loginToHazelcastCloud_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *RemoteControllerLoginToHazelcastCloudArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "baseUrl", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:baseUrl: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.BaseUrl)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.baseUrl (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:baseUrl: ", p), err) }
  return err
}

func (p *RemoteControllerLoginToHazelcastCloudArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "apiKey", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:apiKey: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.ApiKey)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.apiKey (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:apiKey: ", p), err) }
  return err
}

func (p *RemoteControllerLoginToHazelcastCloudArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "apiSecret", thrift.STRING, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:apiSecret: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.ApiSecret)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.apiSecret (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:apiSecret: ", p), err) }
  return err
}

func (p *RemoteControllerLoginToHazelcastCloudArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("RemoteControllerLoginToHazelcastCloudArgs(%+v)", *p)
}

// Attributes:
//  - CloudException
type RemoteControllerLoginToHazelcastCloudResult struct {
  CloudException *CloudException `thrift:"cloudException,1" db:"cloudException" json:"cloudException,omitempty"`
}

func NewRemoteControllerLoginToHazelcastCloudResult() *RemoteControllerLoginToHazelcastCloudResult {
  return &RemoteControllerLoginToHazelcastCloudResult{}
}

var RemoteControllerLoginToHazelcastCloudResult_CloudException_DEFAULT *CloudException
func (p *RemoteControllerLoginToHazelcastCloudResult) GetCloudException() *CloudException {
  if !p.IsSetCloudException() {
    return RemoteControllerLoginToHazelcastCloudResult_CloudException_DEFAULT
  }
return p.CloudException
}
func (p *RemoteControllerLoginToHazelcastCloudResult) IsSetCloudException() bool {
  return p.CloudException != nil
}

func (p *RemoteControllerLoginToHazelcastCloudResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *RemoteControllerLoginToHazelcastCloudResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.CloudException = &CloudException{}
  if err := p.CloudException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.CloudException), err)
  }
  return nil
}

func (p *RemoteControllerLoginToHazelcastCloudResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "loginToHazelcastCloud_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *RemoteControllerLoginToHazelcastCloudResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetCloudException() {
    if err := oprot.WriteFieldBegin(ctx, "cloudException", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:cloudException: ", p), err) }
    if err := p.CloudException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.CloudException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:cloudException: ", p), err) }
  }
  return err
}

func (p *RemoteControllerLoginToHazelcastCloudResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("RemoteControllerLoginToHazelcastCloudResult(%+v)", *p)
}

// Attributes:
//  - HazelcastVersion
//  - IsTlsEnabled
type RemoteControllerCreateHazelcastCloudStandardClusterArgs struct {
  HazelcastVersion string `thrift:"hazelcastVersion,1" db:"hazelcastVersion" json:"hazelcastVersion"`
  IsTlsEnabled bool `thrift:"isTlsEnabled,2" db:"isTlsEnabled" json:"isTlsEnabled"`
}

func NewRemoteControllerCreateHazelcastCloudStandardClusterArgs() *RemoteControllerCreateHazelcastCloudStandardClusterArgs {
  return &RemoteControllerCreateHazelcastCloudStandardClusterArgs{}
}


func (p *RemoteControllerCreateHazelcastCloudStandardClusterArgs) GetHazelcastVersion() string {
  return p.HazelcastVersion
}

func (p *RemoteControllerCreateHazelcastCloudStandardClusterArgs) GetIsTlsEnabled() bool {
  return p.IsTlsEnabled
}
func (p *RemoteControllerCreateHazelcastCloudStandardClusterArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *RemoteControllerCreateHazelcastCloudStandardClusterArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.HazelcastVersion = v
}
  return nil
}

func (p *RemoteControllerCreateHazelcastCloudStandardClusterArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.IsTlsEnabled = v
}
  return nil
}

func (p *RemoteControllerCreateHazelcastCloudStandardClusterArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "createHazelcastCloudStandardCluster_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *RemoteControllerCreateHazelcastCloudStandardClusterArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "hazelcastVersion", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:hazelcastVersion: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.HazelcastVersion)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.hazelcastVersion (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:hazelcastVersion: ", p), err) }
  return err
}

func (p *RemoteControllerCreateHazelcastCloudStandardClusterArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "isTlsEnabled", thrift.BOOL, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:isTlsEnabled: ", p), err) }
  if err := oprot.WriteBool(ctx, bool(p.IsTlsEnabled)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.isTlsEnabled (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:isTlsEnabled: ", p), err) }
  return err
}

func (p *RemoteControllerCreateHazelcastCloudStandardClusterArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("RemoteControllerCreateHazelcastCloudStandardClusterArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - CloudException
type RemoteControllerCreateHazelcastCloudStandardClusterResult struct {
  Success *CloudCluster `thrift:"success,0" db:"success" json:"success,omitempty"`
  CloudException *CloudException `thrift:"cloudException,1" db:"cloudException" json:"cloudException,omitempty"`
}

func NewRemoteControllerCreateHazelcastCloudStandardClusterResult() *RemoteControllerCreateHazelcastCloudStandardClusterResult {
  return &RemoteControllerCreateHazelcastCloudStandardClusterResult{}
}

var RemoteControllerCreateHazelcastCloudStandardClusterResult_Success_DEFAULT *CloudCluster
func (p *RemoteControllerCreateHazelcastCloudStandardClusterResult) GetSuccess() *CloudCluster {
  if !p.IsSetSuccess() {
    return RemoteControllerCreateHazelcastCloudStandardClusterResult_Success_DEFAULT
  }
return p.Success
}
var RemoteControllerCreateHazelcastCloudStandardClusterResult_CloudException_DEFAULT *CloudException
func (p *RemoteControllerCreateHazelcastCloudStandardClusterResult) GetCloudException() *CloudException {
  if !p.IsSetCloudException() {
    return RemoteControllerCreateHazelcastCloudStandardClusterResult_CloudException_DEFAULT
  }
return p.CloudException
}
func (p *RemoteControllerCreateHazelcastCloudStandardClusterResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *RemoteControllerCreateHazelcastCloudStandardClusterResult) IsSetCloudException() bool {
  return p.CloudException != nil
}

func (p *RemoteControllerCreateHazelcastCloudStandardClusterResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *RemoteControllerCreateHazelcastCloudStandardClusterResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &CloudCluster{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *RemoteControllerCreateHazelcastCloudStandardClusterResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.CloudException = &CloudException{}
  if err := p.CloudException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.CloudException), err)
  }
  return nil
}

func (p *RemoteControllerCreateHazelcastCloudStandardClusterResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "createHazelcastCloudStandardCluster_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *RemoteControllerCreateHazelcastCloudStandardClusterResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *RemoteControllerCreateHazelcastCloudStandardClusterResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetCloudException() {
    if err := oprot.WriteFieldBegin(ctx, "cloudException", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:cloudException: ", p), err) }
    if err := p.CloudException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.CloudException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:cloudException: ", p), err) }
  }
  return err
}

func (p *RemoteControllerCreateHazelcastCloudStandardClusterResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("RemoteControllerCreateHazelcastCloudStandardClusterResult(%+v)", *p)
}

// Attributes:
//  - CloudClusterId
//  - TotalMemberCount
type RemoteControllerSetHazelcastCloudClusterMemberCountArgs struct {
  CloudClusterId string `thrift:"cloudClusterId,1" db:"cloudClusterId" json:"cloudClusterId"`
  TotalMemberCount int32 `thrift:"totalMemberCount,2" db:"totalMemberCount" json:"totalMemberCount"`
}

func NewRemoteControllerSetHazelcastCloudClusterMemberCountArgs() *RemoteControllerSetHazelcastCloudClusterMemberCountArgs {
  return &RemoteControllerSetHazelcastCloudClusterMemberCountArgs{}
}


func (p *RemoteControllerSetHazelcastCloudClusterMemberCountArgs) GetCloudClusterId() string {
  return p.CloudClusterId
}

func (p *RemoteControllerSetHazelcastCloudClusterMemberCountArgs) GetTotalMemberCount() int32 {
  return p.TotalMemberCount
}
func (p *RemoteControllerSetHazelcastCloudClusterMemberCountArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *RemoteControllerSetHazelcastCloudClusterMemberCountArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.CloudClusterId = v
}
  return nil
}

func (p *RemoteControllerSetHazelcastCloudClusterMemberCountArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.TotalMemberCount = v
}
  return nil
}

func (p *RemoteControllerSetHazelcastCloudClusterMemberCountArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "setHazelcastCloudClusterMemberCount_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *RemoteControllerSetHazelcastCloudClusterMemberCountArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "cloudClusterId", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:cloudClusterId: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.CloudClusterId)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.cloudClusterId (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:cloudClusterId: ", p), err) }
  return err
}

func (p *RemoteControllerSetHazelcastCloudClusterMemberCountArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "totalMemberCount", thrift.I32, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:totalMemberCount: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.TotalMemberCount)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.totalMemberCount (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:totalMemberCount: ", p), err) }
  return err
}

func (p *RemoteControllerSetHazelcastCloudClusterMemberCountArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("RemoteControllerSetHazelcastCloudClusterMemberCountArgs(%+v)", *p)
}

// Attributes:
//  - CloudException
type RemoteControllerSetHazelcastCloudClusterMemberCountResult struct {
  CloudException *CloudException `thrift:"cloudException,1" db:"cloudException" json:"cloudException,omitempty"`
}

func NewRemoteControllerSetHazelcastCloudClusterMemberCountResult() *RemoteControllerSetHazelcastCloudClusterMemberCountResult {
  return &RemoteControllerSetHazelcastCloudClusterMemberCountResult{}
}

var RemoteControllerSetHazelcastCloudClusterMemberCountResult_CloudException_DEFAULT *CloudException
func (p *RemoteControllerSetHazelcastCloudClusterMemberCountResult) GetCloudException() *CloudException {
  if !p.IsSetCloudException() {
    return RemoteControllerSetHazelcastCloudClusterMemberCountResult_CloudException_DEFAULT
  }
return p.CloudException
}
func (p *RemoteControllerSetHazelcastCloudClusterMemberCountResult) IsSetCloudException() bool {
  return p.CloudException != nil
}

func (p *RemoteControllerSetHazelcastCloudClusterMemberCountResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *RemoteControllerSetHazelcastCloudClusterMemberCountResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.CloudException = &CloudException{}
  if err := p.CloudException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.CloudException), err)
  }
  return nil
}

func (p *RemoteControllerSetHazelcastCloudClusterMemberCountResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "setHazelcastCloudClusterMemberCount_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *RemoteControllerSetHazelcastCloudClusterMemberCountResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetCloudException() {
    if err := oprot.WriteFieldBegin(ctx, "cloudException", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:cloudException: ", p), err) }
    if err := p.CloudException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.CloudException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:cloudException: ", p), err) }
  }
  return err
}

func (p *RemoteControllerSetHazelcastCloudClusterMemberCountResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("RemoteControllerSetHazelcastCloudClusterMemberCountResult(%+v)", *p)
}

// Attributes:
//  - CloudClusterId
type RemoteControllerGetHazelcastCloudClusterArgs struct {
  CloudClusterId string `thrift:"cloudClusterId,1" db:"cloudClusterId" json:"cloudClusterId"`
}

func NewRemoteControllerGetHazelcastCloudClusterArgs() *RemoteControllerGetHazelcastCloudClusterArgs {
  return &RemoteControllerGetHazelcastCloudClusterArgs{}
}


func (p *RemoteControllerGetHazelcastCloudClusterArgs) GetCloudClusterId() string {
  return p.CloudClusterId
}
func (p *RemoteControllerGetHazelcastCloudClusterArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *RemoteControllerGetHazelcastCloudClusterArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.CloudClusterId = v
}
  return nil
}

func (p *RemoteControllerGetHazelcastCloudClusterArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getHazelcastCloudCluster_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *RemoteControllerGetHazelcastCloudClusterArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "cloudClusterId", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:cloudClusterId: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.CloudClusterId)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.cloudClusterId (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:cloudClusterId: ", p), err) }
  return err
}

func (p *RemoteControllerGetHazelcastCloudClusterArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("RemoteControllerGetHazelcastCloudClusterArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - CloudException
type RemoteControllerGetHazelcastCloudClusterResult struct {
  Success *CloudCluster `thrift:"success,0" db:"success" json:"success,omitempty"`
  CloudException *CloudException `thrift:"cloudException,1" db:"cloudException" json:"cloudException,omitempty"`
}

func NewRemoteControllerGetHazelcastCloudClusterResult() *RemoteControllerGetHazelcastCloudClusterResult {
  return &RemoteControllerGetHazelcastCloudClusterResult{}
}

var RemoteControllerGetHazelcastCloudClusterResult_Success_DEFAULT *CloudCluster
func (p *RemoteControllerGetHazelcastCloudClusterResult) GetSuccess() *CloudCluster {
  if !p.IsSetSuccess() {
    return RemoteControllerGetHazelcastCloudClusterResult_Success_DEFAULT
  }
return p.Success
}
var RemoteControllerGetHazelcastCloudClusterResult_CloudException_DEFAULT *CloudException
func (p *RemoteControllerGetHazelcastCloudClusterResult) GetCloudException() *CloudException {
  if !p.IsSetCloudException() {
    return RemoteControllerGetHazelcastCloudClusterResult_CloudException_DEFAULT
  }
return p.CloudException
}
func (p *RemoteControllerGetHazelcastCloudClusterResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *RemoteControllerGetHazelcastCloudClusterResult) IsSetCloudException() bool {
  return p.CloudException != nil
}

func (p *RemoteControllerGetHazelcastCloudClusterResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *RemoteControllerGetHazelcastCloudClusterResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &CloudCluster{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *RemoteControllerGetHazelcastCloudClusterResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.CloudException = &CloudException{}
  if err := p.CloudException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.CloudException), err)
  }
  return nil
}

func (p *RemoteControllerGetHazelcastCloudClusterResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getHazelcastCloudCluster_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *RemoteControllerGetHazelcastCloudClusterResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *RemoteControllerGetHazelcastCloudClusterResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetCloudException() {
    if err := oprot.WriteFieldBegin(ctx, "cloudException", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:cloudException: ", p), err) }
    if err := p.CloudException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.CloudException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:cloudException: ", p), err) }
  }
  return err
}

func (p *RemoteControllerGetHazelcastCloudClusterResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("RemoteControllerGetHazelcastCloudClusterResult(%+v)", *p)
}

// Attributes:
//  - CloudClusterId
type RemoteControllerStopHazelcastCloudClusterArgs struct {
  CloudClusterId string `thrift:"cloudClusterId,1" db:"cloudClusterId" json:"cloudClusterId"`
}

func NewRemoteControllerStopHazelcastCloudClusterArgs() *RemoteControllerStopHazelcastCloudClusterArgs {
  return &RemoteControllerStopHazelcastCloudClusterArgs{}
}


func (p *RemoteControllerStopHazelcastCloudClusterArgs) GetCloudClusterId() string {
  return p.CloudClusterId
}
func (p *RemoteControllerStopHazelcastCloudClusterArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *RemoteControllerStopHazelcastCloudClusterArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.CloudClusterId = v
}
  return nil
}

func (p *RemoteControllerStopHazelcastCloudClusterArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "stopHazelcastCloudCluster_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *RemoteControllerStopHazelcastCloudClusterArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "cloudClusterId", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:cloudClusterId: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.CloudClusterId)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.cloudClusterId (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:cloudClusterId: ", p), err) }
  return err
}

func (p *RemoteControllerStopHazelcastCloudClusterArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("RemoteControllerStopHazelcastCloudClusterArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - CloudException
type RemoteControllerStopHazelcastCloudClusterResult struct {
  Success *CloudCluster `thrift:"success,0" db:"success" json:"success,omitempty"`
  CloudException *CloudException `thrift:"cloudException,1" db:"cloudException" json:"cloudException,omitempty"`
}

func NewRemoteControllerStopHazelcastCloudClusterResult() *RemoteControllerStopHazelcastCloudClusterResult {
  return &RemoteControllerStopHazelcastCloudClusterResult{}
}

var RemoteControllerStopHazelcastCloudClusterResult_Success_DEFAULT *CloudCluster
func (p *RemoteControllerStopHazelcastCloudClusterResult) GetSuccess() *CloudCluster {
  if !p.IsSetSuccess() {
    return RemoteControllerStopHazelcastCloudClusterResult_Success_DEFAULT
  }
return p.Success
}
var RemoteControllerStopHazelcastCloudClusterResult_CloudException_DEFAULT *CloudException
func (p *RemoteControllerStopHazelcastCloudClusterResult) GetCloudException() *CloudException {
  if !p.IsSetCloudException() {
    return RemoteControllerStopHazelcastCloudClusterResult_CloudException_DEFAULT
  }
return p.CloudException
}
func (p *RemoteControllerStopHazelcastCloudClusterResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *RemoteControllerStopHazelcastCloudClusterResult) IsSetCloudException() bool {
  return p.CloudException != nil
}

func (p *RemoteControllerStopHazelcastCloudClusterResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *RemoteControllerStopHazelcastCloudClusterResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &CloudCluster{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *RemoteControllerStopHazelcastCloudClusterResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.CloudException = &CloudException{}
  if err := p.CloudException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.CloudException), err)
  }
  return nil
}

func (p *RemoteControllerStopHazelcastCloudClusterResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "stopHazelcastCloudCluster_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *RemoteControllerStopHazelcastCloudClusterResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *RemoteControllerStopHazelcastCloudClusterResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetCloudException() {
    if err := oprot.WriteFieldBegin(ctx, "cloudException", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:cloudException: ", p), err) }
    if err := p.CloudException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.CloudException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:cloudException: ", p), err) }
  }
  return err
}

func (p *RemoteControllerStopHazelcastCloudClusterResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("RemoteControllerStopHazelcastCloudClusterResult(%+v)", *p)
}

// Attributes:
//  - CloudClusterId
type RemoteControllerResumeHazelcastCloudClusterArgs struct {
  CloudClusterId string `thrift:"cloudClusterId,1" db:"cloudClusterId" json:"cloudClusterId"`
}

func NewRemoteControllerResumeHazelcastCloudClusterArgs() *RemoteControllerResumeHazelcastCloudClusterArgs {
  return &RemoteControllerResumeHazelcastCloudClusterArgs{}
}


func (p *RemoteControllerResumeHazelcastCloudClusterArgs) GetCloudClusterId() string {
  return p.CloudClusterId
}
func (p *RemoteControllerResumeHazelcastCloudClusterArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *RemoteControllerResumeHazelcastCloudClusterArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.CloudClusterId = v
}
  return nil
}

func (p *RemoteControllerResumeHazelcastCloudClusterArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "resumeHazelcastCloudCluster_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *RemoteControllerResumeHazelcastCloudClusterArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "cloudClusterId", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:cloudClusterId: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.CloudClusterId)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.cloudClusterId (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:cloudClusterId: ", p), err) }
  return err
}

func (p *RemoteControllerResumeHazelcastCloudClusterArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("RemoteControllerResumeHazelcastCloudClusterArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - CloudException
type RemoteControllerResumeHazelcastCloudClusterResult struct {
  Success *CloudCluster `thrift:"success,0" db:"success" json:"success,omitempty"`
  CloudException *CloudException `thrift:"cloudException,1" db:"cloudException" json:"cloudException,omitempty"`
}

func NewRemoteControllerResumeHazelcastCloudClusterResult() *RemoteControllerResumeHazelcastCloudClusterResult {
  return &RemoteControllerResumeHazelcastCloudClusterResult{}
}

var RemoteControllerResumeHazelcastCloudClusterResult_Success_DEFAULT *CloudCluster
func (p *RemoteControllerResumeHazelcastCloudClusterResult) GetSuccess() *CloudCluster {
  if !p.IsSetSuccess() {
    return RemoteControllerResumeHazelcastCloudClusterResult_Success_DEFAULT
  }
return p.Success
}
var RemoteControllerResumeHazelcastCloudClusterResult_CloudException_DEFAULT *CloudException
func (p *RemoteControllerResumeHazelcastCloudClusterResult) GetCloudException() *CloudException {
  if !p.IsSetCloudException() {
    return RemoteControllerResumeHazelcastCloudClusterResult_CloudException_DEFAULT
  }
return p.CloudException
}
func (p *RemoteControllerResumeHazelcastCloudClusterResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *RemoteControllerResumeHazelcastCloudClusterResult) IsSetCloudException() bool {
  return p.CloudException != nil
}

func (p *RemoteControllerResumeHazelcastCloudClusterResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *RemoteControllerResumeHazelcastCloudClusterResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &CloudCluster{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *RemoteControllerResumeHazelcastCloudClusterResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.CloudException = &CloudException{}
  if err := p.CloudException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.CloudException), err)
  }
  return nil
}

func (p *RemoteControllerResumeHazelcastCloudClusterResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "resumeHazelcastCloudCluster_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *RemoteControllerResumeHazelcastCloudClusterResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *RemoteControllerResumeHazelcastCloudClusterResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetCloudException() {
    if err := oprot.WriteFieldBegin(ctx, "cloudException", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:cloudException: ", p), err) }
    if err := p.CloudException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.CloudException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:cloudException: ", p), err) }
  }
  return err
}

func (p *RemoteControllerResumeHazelcastCloudClusterResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("RemoteControllerResumeHazelcastCloudClusterResult(%+v)", *p)
}

// Attributes:
//  - CloudClusterId
type RemoteControllerDeleteHazelcastCloudClusterArgs struct {
  CloudClusterId string `thrift:"cloudClusterId,1" db:"cloudClusterId" json:"cloudClusterId"`
}

func NewRemoteControllerDeleteHazelcastCloudClusterArgs() *RemoteControllerDeleteHazelcastCloudClusterArgs {
  return &RemoteControllerDeleteHazelcastCloudClusterArgs{}
}


func (p *RemoteControllerDeleteHazelcastCloudClusterArgs) GetCloudClusterId() string {
  return p.CloudClusterId
}
func (p *RemoteControllerDeleteHazelcastCloudClusterArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *RemoteControllerDeleteHazelcastCloudClusterArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.CloudClusterId = v
}
  return nil
}

func (p *RemoteControllerDeleteHazelcastCloudClusterArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "deleteHazelcastCloudCluster_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *RemoteControllerDeleteHazelcastCloudClusterArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "cloudClusterId", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:cloudClusterId: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.CloudClusterId)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.cloudClusterId (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:cloudClusterId: ", p), err) }
  return err
}

func (p *RemoteControllerDeleteHazelcastCloudClusterArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("RemoteControllerDeleteHazelcastCloudClusterArgs(%+v)", *p)
}

// Attributes:
//  - CloudException
type RemoteControllerDeleteHazelcastCloudClusterResult struct {
  CloudException *CloudException `thrift:"cloudException,1" db:"cloudException" json:"cloudException,omitempty"`
}

func NewRemoteControllerDeleteHazelcastCloudClusterResult() *RemoteControllerDeleteHazelcastCloudClusterResult {
  return &RemoteControllerDeleteHazelcastCloudClusterResult{}
}

var RemoteControllerDeleteHazelcastCloudClusterResult_CloudException_DEFAULT *CloudException
func (p *RemoteControllerDeleteHazelcastCloudClusterResult) GetCloudException() *CloudException {
  if !p.IsSetCloudException() {
    return RemoteControllerDeleteHazelcastCloudClusterResult_CloudException_DEFAULT
  }
return p.CloudException
}
func (p *RemoteControllerDeleteHazelcastCloudClusterResult) IsSetCloudException() bool {
  return p.CloudException != nil
}

func (p *RemoteControllerDeleteHazelcastCloudClusterResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *RemoteControllerDeleteHazelcastCloudClusterResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.CloudException = &CloudException{}
  if err := p.CloudException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.CloudException), err)
  }
  return nil
}

func (p *RemoteControllerDeleteHazelcastCloudClusterResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "deleteHazelcastCloudCluster_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *RemoteControllerDeleteHazelcastCloudClusterResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetCloudException() {
    if err := oprot.WriteFieldBegin(ctx, "cloudException", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:cloudException: ", p), err) }
    if err := p.CloudException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.CloudException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:cloudException: ", p), err) }
  }
  return err
}

func (p *RemoteControllerDeleteHazelcastCloudClusterResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("RemoteControllerDeleteHazelcastCloudClusterResult(%+v)", *p)
}

// Attributes:
//  - ClusterId
//  - Script
//  - Lang
type RemoteControllerExecuteOnControllerArgs struct {
  ClusterId string `thrift:"clusterId,1" db:"clusterId" json:"clusterId"`
  Script string `thrift:"script,2" db:"script" json:"script"`
  Lang Lang `thrift:"lang,3" db:"lang" json:"lang"`
}

func NewRemoteControllerExecuteOnControllerArgs() *RemoteControllerExecuteOnControllerArgs {
  return &RemoteControllerExecuteOnControllerArgs{}
}


func (p *RemoteControllerExecuteOnControllerArgs) GetClusterId() string {
  return p.ClusterId
}

func (p *RemoteControllerExecuteOnControllerArgs) GetScript() string {
  return p.Script
}

func (p *RemoteControllerExecuteOnControllerArgs) GetLang() Lang {
  return p.Lang
}
func (p *RemoteControllerExecuteOnControllerArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *RemoteControllerExecuteOnControllerArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.ClusterId = v
}
  return nil
}

func (p *RemoteControllerExecuteOnControllerArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Script = v
}
  return nil
}

func (p *RemoteControllerExecuteOnControllerArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  temp := Lang(v)
  p.Lang = temp
}
  return nil
}

func (p *RemoteControllerExecuteOnControllerArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "executeOnController_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *RemoteControllerExecuteOnControllerArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "clusterId", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:clusterId: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.ClusterId)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.clusterId (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:clusterId: ", p), err) }
  return err
}

func (p *RemoteControllerExecuteOnControllerArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "script", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:script: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Script)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.script (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:script: ", p), err) }
  return err
}

func (p *RemoteControllerExecuteOnControllerArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "lang", thrift.I32, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:lang: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Lang)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.lang (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:lang: ", p), err) }
  return err
}

func (p *RemoteControllerExecuteOnControllerArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("RemoteControllerExecuteOnControllerArgs(%+v)", *p)
}

// Attributes:
//  - Success
type RemoteControllerExecuteOnControllerResult struct {
  Success *Response `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewRemoteControllerExecuteOnControllerResult() *RemoteControllerExecuteOnControllerResult {
  return &RemoteControllerExecuteOnControllerResult{}
}

var RemoteControllerExecuteOnControllerResult_Success_DEFAULT *Response
func (p *RemoteControllerExecuteOnControllerResult) GetSuccess() *Response {
  if !p.IsSetSuccess() {
    return RemoteControllerExecuteOnControllerResult_Success_DEFAULT
  }
return p.Success
}
func (p *RemoteControllerExecuteOnControllerResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *RemoteControllerExecuteOnControllerResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *RemoteControllerExecuteOnControllerResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &Response{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *RemoteControllerExecuteOnControllerResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "executeOnController_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *RemoteControllerExecuteOnControllerResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *RemoteControllerExecuteOnControllerResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("RemoteControllerExecuteOnControllerResult(%+v)", *p)
}


