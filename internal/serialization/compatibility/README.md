The serialization binary compatibility file is autogenerated using the following file from the Hazelcast repository.

https://github.com/hazelcast/hazelcast/blob/master/hazelcast/src/test/java/com/hazelcast/nio/serialization/compatibility/BinaryCompatibilityFileGenerator.java

**ReferenceObjects.java**
```java
package com.hazelcast.nio.serialization.compatibility;
import static java.util.Arrays.asList;
import com.hazelcast.aggregation.Aggregators;
import com.hazelcast.core.EntryEventType;
import com.hazelcast.internal.serialization.Data;
import com.hazelcast.internal.serialization.impl.HeapData;
import com.hazelcast.nio.serialization.Portable;
import com.hazelcast.query.Predicates;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.time.OffsetDateTime;
import java.time.ZoneOffset;
import java.util.AbstractMap;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.Optional;
import java.util.UUID;
class ReferenceObjects {
    /**
     * PORTABLE IDS
     **/
    static int PORTABLE_FACTORY_ID = 1;
    static int PORTABLE_CLASS_ID = 1;
    static int INNER_PORTABLE_CLASS_ID = 2;
    /**
     * IDENTIFIED DATA SERIALIZABLE IDS
     **/
    static int IDENTIFIED_DATA_SERIALIZABLE_FACTORY_ID = 1;
    static int DATA_SERIALIZABLE_CLASS_ID = 1;
    /**
     * CUSTOM SERIALIZER IDS
     */
    static int CUSTOM_STREAM_SERIALIZABLE_ID = 1;
    static int CUSTOM_BYTE_ARRAY_SERIALIZABLE_ID = 2;
    /**
     * OBJECTS
     */
    static Object aNullObject = null;
    static boolean aBoolean = true;
    static byte aByte = 113;
    static char aChar = 'x';
    static double aDouble = -897543.3678909d;
    static short aShort = -500;
    static float aFloat = 900.5678f;
    static int anInt = 56789;
    static long aLong = -50992225L;
    static String anSqlString = "this > 5 AND this < 100";
    static String aString = anSqlString;
    static UUID aUUID = new UUID(aLong, anInt);
    static String aSmallString = "😊 Hello Приве́т नमस्ते שָׁלוֹם";
    static boolean[] booleans = {true, false, true};
    static byte[] bytes = {112, 4, 1, 4, 112, 35, 43};
    static char[] chars = {'a', 'b', 'c'};
    static double[] doubles = {-897543.3678909d, 11.1d, 22.2d, 33.3d};
    static short[] shorts = {-500, 2, 3};
    static float[] floats = {900.5678f, 1.0f, 2.1f, 3.4f};
    static int[] ints = {56789, 2, 3};
    static long[] longs = {-50992225L, 1231232141L, 2L, 3L};
    static String[] strings = {
            "Pijamalı hasta, yağız şoföre çabucak güvendi.",
            "イロハニホヘト チリヌルヲ ワカヨタレソ ツネナラム",
            "The quick brown fox jumps over the lazy dog",
    };
    static Data aData = new HeapData("111313123131313131".getBytes());
    static AnInnerPortable anInnerPortable = new AnInnerPortable(anInt, aFloat);
    static CustomStreamSerializable aCustomStreamSerializable = new CustomStreamSerializable(anInt, aFloat);
    static CustomByteArraySerializable aCustomByteArraySerializable = new CustomByteArraySerializable(anInt, aFloat);
    static Portable[] portables = {anInnerPortable, anInnerPortable, anInnerPortable};
    static AbstractMap.SimpleEntry aSimpleMapEntry = new AbstractMap.SimpleEntry(aSmallString, anInnerPortable);
    static AbstractMap.SimpleImmutableEntry aSimpleImmutableMapEntry = new AbstractMap.SimpleImmutableEntry(aSmallString,
            anInnerPortable);
    static AnIdentifiedDataSerializable anIdentifiedDataSerializable = new AnIdentifiedDataSerializable(
            aBoolean, aByte, aChar, aDouble, aShort, aFloat, anInt, aLong, anSqlString,
            booleans, bytes, chars, doubles, shorts, floats, ints, longs, strings,
            anInnerPortable, null,
            aCustomStreamSerializable,
            aCustomByteArraySerializable, aData);
    static Date aDate;
    static LocalDate aLocalDate;
    static LocalTime aLocalTime;
    static LocalDateTime aLocalDateTime;
    static OffsetDateTime aOffsetDateTime;
    static LocalDate[] localDates;
    static LocalTime[] localTimes;
    static LocalDateTime[] localDateTimes;
    static OffsetDateTime[] offsetDateTimes;
    static {
        Calendar calendar = Calendar.getInstance();
        calendar.set(1990, Calendar.FEBRUARY, 1, 0, 0, 0);
        calendar.set(Calendar.MILLISECOND, 0);
        calendar.set(Calendar.ZONE_OFFSET, 0);
        calendar.set(Calendar.DST_OFFSET, 0);
        aDate = calendar.getTime();
        aLocalDate = LocalDate.of(2021, 6, 28);
        aLocalTime = LocalTime.of(11, 22, 41, 123456789);
        aLocalDateTime = LocalDateTime.of(aLocalDate, aLocalTime);
        aOffsetDateTime = OffsetDateTime.of(aLocalDateTime, ZoneOffset.ofHours(18));
        localDates= new LocalDate[]{
                LocalDate.of(2021, 6, 28),
                LocalDate.of(1923, 4, 23),
                LocalDate.of(1938, 11, 10)};
        localTimes = new LocalTime[]{
                LocalTime.of(9, 5, 10, 123456789),
                LocalTime.of(18, 30, 55, 567891234),
                LocalTime.of(15, 44, 39, 192837465)};
        localDateTimes= new LocalDateTime[]{
                LocalDateTime.of(LocalDate.of(1938, 11, 10), LocalTime.of(9, 5, 10, 123456789)),
                LocalDateTime.of(LocalDate.of(1923, 4, 23), LocalTime.of(15, 44, 39, 192837465)),
                LocalDateTime.of(LocalDate.of(2021, 6, 28), LocalTime.of(18, 30, 55, 567891234))};
        offsetDateTimes= new OffsetDateTime[]{
                OffsetDateTime.of(LocalDate.of(1938, 11, 10), LocalTime.of(9, 5, 10, 123456789),
                        ZoneOffset.ofHours(18)),
                OffsetDateTime.of(LocalDateTime.of(LocalDate.of(1923, 4, 23), LocalTime.of(15, 44, 39, 192837465)),
                        ZoneOffset.ofHours(5)),
                OffsetDateTime.of(LocalDateTime.of(LocalDate.of(2021, 6, 28), LocalTime.of(18, 30, 55, 567891234)),
                        ZoneOffset.ofHours(-10))};
    }
    static BigInteger aBigInteger = new BigInteger("1314432323232411");
    static BigDecimal aBigDecimal = new BigDecimal(31231);
    static BigDecimal[] decimals = {aBigDecimal, aBigDecimal ,aBigDecimal};
    static APortable aPortable = new APortable(
            aBoolean, aByte, aChar, aDouble, aShort, aFloat, anInt, aLong, anSqlString, aBigDecimal,
            aLocalDate, aLocalTime, aLocalDateTime, aOffsetDateTime, anInnerPortable,
            booleans, bytes, chars, doubles, shorts, floats, ints, longs, strings, decimals,
            localDates, localTimes, localDateTimes, offsetDateTimes, portables,
            anIdentifiedDataSerializable,
            aCustomStreamSerializable,
            aCustomByteArraySerializable, aData);
    static Class aClass = BigDecimal.class;
    static Optional<String> aFullOptional = Optional.of("SERIALIZEDSTRING");
    static Optional<String> anEmptyOptional = Optional.empty();
    static Enum anEnum = EntryEventType.ADDED;
    static ArrayList nonNullList = new ArrayList(asList(
            aBoolean, aByte, aChar, aDouble, aShort, aFloat, anInt, aLong, aSmallString, anInnerPortable,
            booleans, bytes, chars, doubles, shorts, floats, ints, longs, strings,
            aCustomStreamSerializable, aCustomByteArraySerializable,
            anIdentifiedDataSerializable, aPortable,
            aDate, aLocalDate, aLocalTime, aLocalDateTime, aOffsetDateTime, aBigInteger, aBigDecimal, aClass,
            anEmptyOptional, aFullOptional, anEnum, aSimpleMapEntry, aSimpleImmutableMapEntry
            ));
    static Object[] allTestObjects = {
            aNullObject, aBoolean, aByte, aChar, aDouble, aShort, aFloat, anInt, aLong, aString, aUUID, anInnerPortable,
            aSimpleMapEntry, aSimpleImmutableMapEntry, booleans, bytes, chars, doubles, shorts, floats, ints, longs, strings,
            aCustomStreamSerializable, aCustomByteArraySerializable,
            anIdentifiedDataSerializable, aPortable,
            aDate, aLocalDate, aLocalTime, aLocalDateTime, aOffsetDateTime, aBigInteger, aBigDecimal, aClass,
            aFullOptional, anEnum,
            // predicates
            Predicates.alwaysTrue(),
            Predicates.alwaysFalse(),
            Predicates.sql(anSqlString),
            Predicates.equal(anSqlString, anInt),
            Predicates.notEqual(anSqlString, anInt),
            Predicates.greaterThan(anSqlString, anInt),
            Predicates.between(anSqlString, anInt, anInt),
            Predicates.like(anSqlString, anSqlString),
            Predicates.ilike(anSqlString, anSqlString),
            Predicates.in(anSqlString, anInt, anInt),
            Predicates.regex(anSqlString, anSqlString),
            Predicates.and(Predicates.sql(anSqlString),
                    Predicates.equal(anSqlString, anInt),
                    Predicates.notEqual(anSqlString, anInt),
                    Predicates.greaterThan(anSqlString, anInt),
                    Predicates.greaterEqual(anSqlString, anInt)),
            Predicates.or(Predicates.sql(anSqlString),
                    Predicates.equal(anSqlString, anInt),
                    Predicates.notEqual(anSqlString, anInt),
                    Predicates.greaterThan(anSqlString, anInt),
                    Predicates.greaterEqual(anSqlString, anInt)),
            Predicates.instanceOf(aCustomStreamSerializable.getClass()),
            // Aggregators
            Aggregators.count(anSqlString),
            Aggregators.distinct(anSqlString),
            Aggregators.maxBy(anSqlString),
            Aggregators.minBy(anSqlString),
            Aggregators.comparableMax(anSqlString),
            Aggregators.comparableMin(anSqlString),
            Aggregators.doubleSum(anSqlString),
            Aggregators.integerSum(anSqlString),
            Aggregators.longSum(anSqlString),
            Aggregators.doubleAvg(anSqlString),
            Aggregators.integerAvg(anSqlString),
            Aggregators.longAvg(anSqlString),
    };
}
```